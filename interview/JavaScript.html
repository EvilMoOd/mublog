<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/mublog/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/mublog/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="木糖不爱吃糖" href="https://evilmood.github.io/mublog/rss.xml"><link rel="alternate" type="application/atom+xml" title="木糖不爱吃糖" href="https://evilmood.github.io/mublog/atom.xml"><link rel="alternate" type="application/json" title="木糖不爱吃糖" href="https://evilmood.github.io/mublog/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=ZCOOL%20KuaiLe:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7Cyin:300,300italic,400,400italic,700,700italic%7CJetBrains%20Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/mublog/css/app.css?v=0.2.5"><link rel="canonical" href="https://evilmood.github.io/mublog/interview/JavaScript"><title>JavaScript与其框架 | Evil MoOd = 木糖不爱吃糖 = 山有木兮木有枝，心悦君兮君不知</title><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">JavaScript与其框架</h1></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/mublog/" rel="start">Evil MoOd</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://pic.imgdb.cn/item/65c59c949f345e8d03ba47b9.jpg"></li><li class="item" data-background-image="https://pic.imgdb.cn/item/65c59c169f345e8d03b984bf.jpg"></li><li class="item" data-background-image="https://pic.imgdb.cn/item/65c59bea9f345e8d03b93e50.jpg"></li><li class="item" data-background-image="https://pic.imgdb.cn/item/65c59cde9f345e8d03bac10b.jpg"></li><li class="item" data-background-image="https://pic.imgdb.cn/item/65c59d0b9f345e8d03bb08e7.jpg"></li><li class="item" data-background-image="https://pic.imgdb.cn/item/65c59ab19f345e8d03b73496.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="page wrap"><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://evilmood.github.io/mublog/interview/JavaScript.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/mublog/images/avatar.jpg"><meta itemprop="name" content="EvilMoOd"><meta itemprop="description" content="山有木兮木有枝，心悦君兮君不知, 摸鱼是第一生产力"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="木糖不爱吃糖"></span><div class="body md" itemprop="articleBody"><h2 id="javascript"><a class="anchor" href="#javascript">#</a> JavaScript</h2><h3 id="基础"><a class="anchor" href="#基础">#</a> 基础</h3><h4 id="数据类型"><a class="anchor" href="#数据类型">#</a> 数据类型</h4><details class="warning"><summary>数据类型检测的四种方法</summary><div><ol><li>typeof（缺点：数组和 null 会被判定为 object）</li><li>instanceof（缺点：只能判断引用类型）</li><li>Object.prototype.toString.call()</li><li>constructor（缺点：对象原型改变时无法正确检测类型）</li></ol></div></details><details class="warning"><summary>隐式类型转换</summary><div><p><img data-src="https://yck-1254263422.cos.ap-shanghai.myqcloud.com/blog/2019-06-01-043719.png" alt="type"></p></div></details><details class="warning"><summary>ull和undefined的区别</summary><div><p>null 是一个表示” 无” 的对象，转为数值时为 0；undefined 是一个表示” 无” 的原始值，转为数值时为 NaN。<br>当声明的变量还未被初始化时，变量的默认值为 undefined。<br>null 用来表示尚未存在的对象，常用来表示函数企图返回一个不存在的对象。</p><p>undefined 表示” 缺少值”，就是此处应该有一个值，但是还没有定义。典型用法是：</p><ol><li>变量被声明了，但没有赋值时，就等于 undefined。</li><li>调用函数时，应该提供的参数没有提供，该参数等于 undefined。</li><li>对象没有赋值的属性，该属性的值为 undefined。</li><li>函数没有返回值时，默认返回 undefined。</li></ol><p>null 表示” 没有对象”，即该处不应该有值。典型用法是：</p><ol><li>作为函数的参数，表示该函数的参数不是对象。</li><li>作为对象原型链的终点。</li></ol></div></details><details class="warning"><summary>类型转换规则</summary><div><ol><li>首先会判断两者类型是否相同，相同的话就比较两者的大小；</li><li>类型不相同的话，就会进行类型转换；</li><li>会先判断是否在对比 null 和 undefined，是的话就会返回 true</li><li>判断两者类型是否为 string 和 number，是的话就会将字符串转换为 number</li><li>判断其中一方是否为 boolean，是的话就会把 boolean 转为 number 再进行判断</li><li>判断其中一方是否为 object 且另一方为 string、number 或者 symbol，是的话就会把 object 转为原始类型再进行判断</li></ol><p><code>其他值转字符串</code></p><ul><li>Null 和 Undefined 类型 ，null 转换为 &quot;null&quot;，undefined 转换为 &quot;undefined&quot;，</li><li>Boolean 类型，true 转换为 &quot;true&quot;，false 转换为 &quot;false&quot;。</li><li>Number 类型的值直接转换，不过那些极小和极大的数字会使用指数形式。</li><li>Symbol 类型的值直接转换，但是只允许显式强制类型转换，使用隐式强制类型转换会产生错误。</li><li>对普通对象来说，除非自行定义 toString () 方法，否则会调用 toString ()（Object.prototype.toString ()）来返回内部属性 [[Class]] 的值，如 &quot;[object Object]&quot;。如果对象有自己的 toString () 方法，字符串化时就会调用该方法并使用其返回值。</li></ul><p><code>其他值转数字</code></p><ul><li>Undefined 类型的值转换为 NaN。</li><li>Null 类型的值转换为 0。</li><li>Boolean 类型的值，true 转换为 1，false 转换为 0。</li><li>String 类型的值转换如同使用 Number () 函数进行转换，如果包含非数字值则转换为 NaN，空字符串为 0。</li><li>Symbol 类型的值不能转换为数字，会报错。</li><li>对象（包括数组）会首先被转换为相应的基本类型值，如果返回的是非数字的基本类型值，则再遵循以上规则将其强制转换为数字。</li></ul><p>为了将值转换为相应的基本类型值，抽象操作 ToPrimitive 会首先（通过内部操作 DefaultValue）检查该值是否有 valueOf () 方法。如果有并且返回基本类型值，就使用该值进行强制类型转换。如果没有就使用 toString () 的返回值（如果存在）来进行强制类型转换。</p><p>如果 valueOf () 和 toString () 均不返回基本类型值，会产生 TypeError 错误。</p><p><code>其他值转布尔值</code><br>以下这些是假值：</p><ul><li>undefined</li><li>null</li><li>false</li><li>+0、-0 和 NaN</li><li>&quot;&quot;</li></ul></div></details><details class="warning"><summary>undefined>=undefined、null>=null、[]==![]</summary><div><p>涉及隐式转换</p><ol><li>NaN&gt;=NaN,false</li><li>0&gt;=0，true</li><li>[]==false -&gt; []==0 -&gt; ''<mark>0 -&gt; 0</mark>0 ,true</li></ol></div></details><details class="warning"><summary>includes和indexOf差别</summary><div><p>includes 内部使用 Number.isNaN 对 NaN 进行检测，而 indexOf 无法检测 NaN</p></div></details><details class="warning"><summary>介绍一下Set、Map、WeakSet、WeakMap的区别</summary><div><p>Set：不能出现重复的原始值和引用值<br>Map：键值对的集合，类似一个字典表<br>WeakSet：成员都是对象且弱引用，可以被垃圾回收机制回收从而防止内存泄漏，可以保存 DOM 节点<br>WeakMap：只接受对象作为键名（null 除外）且是弱引用，值任意，键名所指向的对象可以被垃圾回收机制回收，此时键名无效不能遍历，方法只有 get、set、has、delete</p></div></details><h4 id="核心"><a class="anchor" href="#核心">#</a> 核心</h4><details class="warning"><summary>var和let、const的区别和实现原理</summary><div><ol><li>var 和 let 声明变量，const 声明常量且必须初始化赋值</li><li>var 是函数作用域，let、const 是块级作用域，所以 let 和 const 无法存在 window 上</li><li>var 存在变量提升，在 var 之前打印变量返回 undefined，而 let 和 const 不存在变量提升会报错（暂时性死区）</li><li>var 可以重复声明，let 和 const 不行</li></ol><p>JS 引擎在读取变量时，先找到变量绑定的内存地址，然后找到地址所指向的内存空间，最后读取其中内容，当变量改变时，JS 引擎不会用新值覆盖之前的旧值的内存空间，而是重新分配一个新的内存空间来存储新值，并将新的内存地址与变量进行绑定，JS 引擎会在何时的时机进行 GC，回收旧的内存空间<br>const 定义常量时，变量名与内存地址之间建立一种不可变的绑定关系，阻隔变量地址改变，当 const 定义的变量重新赋值时，JS 引擎会抛出异常</p></div></details><details class="warning"><summary>new操作符做了什么</summary><div><ol><li>在内存中创建一个新对象。</li><li>将新对象内部的 <strong>proto</strong> 赋值为构造函数的 prototype 属性。</li><li>将构造函数内部的 this 被赋值为新对象（即 this 指向新对象）。</li><li>执行构造函数内部的代码（给新对象添加属性）。</li><li>如果构造函数返回非空对象，则返回该对象。否则返回 this。</li></ol></div></details><details class="warning"><summary>讲讲JS继承方式</summary><div><ol><li>原型链继承</li><li>构造函数继承</li><li>组合继承</li><li>寄生组合继承</li><li>class 继承</li></ol><p>具体原理、优缺点、实现可搜索相关贴子或教材</p></div></details><details class="warning"><summary>箭头函数特性</summary><div><ol><li>没有 this，call ()、apply ()、bind () 等方法不能改变箭头函数中 this 的指向</li><li>没有 prototype，故不能作为构造函数</li><li>没有 arguments 对象</li><li>箭头函数不能用作 Generator 函数，不能使用 yeild 关键字</li></ol></div></details><details class="warning"><summary>forEach如何跳出循环</summary><div><p>try catch 捕获函数，在特定条件下 throw error</p></div></details><details class="warning"><summary>[1,2,3].map(parseInt)</summary><div><p>[1,NaN,NaN]<br>parseInt(value,index)<br>parseInt(1,0)、parseInt(2,1)、parseInt(3,2)</p></div></details><details class="warning"><summary>高阶函数</summary><div><p>高阶函数是指传入参数为函数（数组的 map、reduce、forEach）或输出参数为函数（手写 add）</p></div></details><details class="warning"><summary>a==1 && a==2 && a==3</summary><div><p></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拦截法</span></span><br><span class="line"><span class="keyword">var</span> val = <span class="number">0</span>;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="variable language_">window</span>, <span class="string">&#x27;a&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> ++val;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重写toString（node环境无效）</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  <span class="attr">i</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">toString</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a.<span class="property">i</span>++;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重写数组方法</span></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">a.<span class="property">join</span> = a.<span class="property">shift</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p></p></div></details><details class="warning"><summary>立即执行函数作用域</summary><div><p></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="number">10</span>;</span><br><span class="line">(<span class="keyword">function</span> <span class="title function_">b</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="comment">// 内部作用域，会先去查找是有已有变量b的声明，有就直接赋值20，确实有了呀。发现了具名函数 function b()&#123;&#125;，拿此b做赋值；</span></span><br><span class="line">   <span class="comment">// IIFE的函数无法进行赋值（内部机制，类似const定义的常量），所以无效。</span></span><br><span class="line">  <span class="comment">// （这里说的“内部机制”，想搞清楚，需要去查阅一些资料，弄明白IIFE在JS引擎的工作方式，堆栈存储IIFE的方式等）</span></span><br><span class="line">    b = <span class="number">20</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// [Function b]</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">b</span>); <span class="comment">// 10，不是20</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p></p><p>严格模式下，会报错 &quot;Uncaught TypeError: Assignment to constant variable.&quot;</p></div></details><details class="warning"><summary>call 和 apply 的区别是什么，哪个性能更好一些</summary><div><p>call 更好一些，因为 apply 多了一次将数组解构的操作</p></div></details><p>+++</p><h4 id="概念机制"><a class="anchor" href="#概念机制">#</a> 概念机制</h4><details class="warning"><summary>严格模式</summary><div><p><code>规则：</code></p><ul><li>变量必须声明后再使用</li><li>函数的参数不能有同名属性，否则报错</li><li>不能使用 with 语句</li><li>不能对只读属性赋值，否则报错</li><li>不能使用前缀 0 表示八进制数，否则报错</li><li>不能删除不可删除的属性，否则报错</li><li>不能删除变量 delete prop，会报错，只能删除属性 delete global [prop]</li><li>eval 不会在它的外层作用域引入变量</li><li>eval 和 arguments 不能被重新赋值</li><li>arguments 不会自动反映函数参数的变化</li><li>不能使用 arguments.callee</li><li>不能使用 arguments.caller</li><li>禁止 this 指向全局对象</li><li>不能使用 fn.caller 和 fn.arguments 获取函数调用的堆栈</li><li>增加了保留字（比如 protected、static 和 interface）</li></ul><p><code>目的：</code></p><ul><li>消除 Javascript 语法的一些不合理、不严谨之处，减少一些怪异行为；</li><li>消除代码运行的一些不安全之处，保证代码运行的安全；</li><li>提高编译器效率，增加运行速度；</li><li>为未来新版本的 Javascript 做好铺垫。</li></ul></div></details><details class="warning"><summary>内存泄漏</summary><div><p>内存泄漏是指，应当被回收的对象没有被正常回收，变成常驻老生代的对象，导致内存占用越来越高。内存泄漏会导致应用程序速度变慢、高延时、崩溃等问题。</p><p>内存生命周期包括</p><ol><li>分配：按需分配内存。</li><li>使用：读写已分配的内存。</li><li>释放：释放不再需要的内存。</li></ol><p>常见原因</p><ol><li>全局变量没有手动回收。</li><li>函数变量闭包</li><li>使用 JavaScript 对象来做缓存，且不设置过期策略和对象大小控制。</li><li>定时器未解绑</li><li>事件监听未销毁</li></ol></div></details><details class="warning"><summary>垃圾回收</summary><div><p>V8 中有两个垃圾收集器。主要的 GC 使用 Mark-Compact 垃圾回收算法，从整个堆中收集垃圾。小型 GC 使用 Scavenger 垃圾回收算法，收集新生代垃圾。两种不同的算法应对不同的场景：</p><ul><li>使用 Scavenger 算法主要处理存活周期短的对象中的可访问对象。</li><li>使用 Mark-Compact 算法主要处理存活周期长的对象中的不可访问的对象。</li></ul><p>因为新生代中存活的可访问对象占少数，老生代中的不可访问对象占少数，所以这两种回收算法配合使用十分高效。</p><ol><li>分代垃圾收集<br>在 V8 中，所有的 JavaScript 对象都通过堆来分配。V8 将其管理的堆分成两代：新生代和老生代。其中新生代又可细分为两个子代（Nursery、Intermediate）。即新生代中的对象为存活时间较短的对象，老生代中的对象为存活时间较长或常驻内存的对象。</li></ol><p><img data-src="https://user-images.githubusercontent.com/17002181/126338733-69da76cd-33f3-4d0b-9a8e-c0e67ce0a331.png" alt="分代垃圾收集"><br>2. Mark-Compact 算法（Major GC）<br>Mark-Compact 算法可以看作是 Mark-Sweep（标记清除）算法和 Cheney 复制算法的结合。该算法主要分为三个阶段：标记、清除、整理。</p><p><img data-src="https://user-images.githubusercontent.com/17002181/126341694-f3a454c4-4d88-4f7c-80b8-f323843eb6a3.png" alt="Major GC"></p><p>（1）标记（Mark）：标记是找所有可访问对象的过程。GC 会从一组已知的对象指针（称为根集，包括执行堆栈和全局对象等）中，进行递归标记可访问对象。<br>（2）清除（Sweep）：清除是将不可访问的对象留下的内存空间，添加到空闲链表（free list）的过程。未来为新对象分配内存时，可以从空闲链表中进行再分配。<br>（3）整理（Compact）：整理是将可访问对象，往内存一端移动的过程。主要解决标记清除阶段后，内存空间出现较多内存碎片时，可能导致无法分配大对象，而提前触发垃圾回收的问题。<br>3. Scavenger 算法（Minor GC）<br>V8 对新生代内存空间采用了 Scavenger 算法，该算法使用了 semi-space（半空间） 的设计：将堆一分为二，始终只使用一半的空间：From-Space 为使用空间，To-Space 为空闲空间。</p><p><img data-src="https://user-images.githubusercontent.com/17002181/126367817-b5a12c03-18ea-4eb9-8bdb-84d2fd3e8aad.png" alt="Minor GC"><br>新生代在 From-Space 中分配对象；在垃圾回收阶段，检查并按需复制 From-Space 中的可访问对象到 To-Space 或老生代，并释放 From-Space 中的不可访问对象占用的内存空间；最后 From-Space 和 To-Space 角色互换。</p><div class="note warning no-icon"><p>被淘汰的引用计数法：跟踪每个变量被使用的情况，当声明或赋值时引用 count+1，如果变量的值改变则原值引用 count-1，循环时回收引用次数为 0 的变量，但有循环引用导致内存泄漏的问题</p></div></div></details><details class="warning"><summary>模块化AMD和CommonJs的理解</summary><div><p>CommonJS 加载模块是同步的，适用 nodeJs，因为本地加载很快，拷贝输出，可修改引用值，运行时<br>AMD 规范则是异步步加载模块，允许指定回调函数，适用浏览器，网络请求不一定很快，引用输出，只读，编译时</p></div></details><h3 id="es6"><a class="anchor" href="#es6">#</a> ES6</h3><h3 id="作用域-作用域链-闭包-预编译"><a class="anchor" href="#作用域-作用域链-闭包-预编译">#</a> 作用域、作用域链、闭包、预编译</h3><details class="warning"><summary>作用域和作用域链的理解</summary><div><p>函数的变量访问基于函数目前所处的环境，优先访问函数作用域也就是代码块中的变量，若没有则沿作用域链向上单向访问直到 window/global</p></div></details><h3 id="原型-原型链-继承-this"><a class="anchor" href="#原型-原型链-继承-this">#</a> 原型、原型链、继承、this</h3><details class="warning"><summary>JS 中 this 的五种情况</summary><div><ol><li>作为普通函数执行时，this 指向 window。</li><li>当函数作为对象的方法被调用时，this 就会指向该对象。</li><li>构造器调用，this 指向返回的这个对象。</li><li>箭头函数 箭头函数的 this 绑定看的是 this 所在函数定义在哪个对象下，就绑定哪个对象。如果有嵌套的情况，则 this 绑定到最近的一层对象上。</li><li>基于 Function.prototype 上的 apply 、 call 和 bind 调用模式，这三个方法都可以显示的指定调用函数的 this 指向。apply 接收参数的是数组，call 接受参数列表，bind 方法通过传入一个对象，返回一个 this 绑定了传入对象的新函数。这个函数的 this 指向除了使用 new 时会被改变，其他情况下都不会改变。若为空默认是指向全局对象 window。</li></ol></div></details><h3 id="异步编程"><a class="anchor" href="#异步编程">#</a> 异步编程</h3><details class="warning"><summary>浏览器和Node中的事件循环</summary><div><p>JS 是单线程的，为了防止一个函数执行时间过长阻塞后面的代码，所以会先将同步代码压入执行栈中，依次执行，将异步代码推入异步队列，异步队列又分为宏任务队列和微任务队列，因为宏任务队列的执行时间较长，所以微任务队列要优先于宏任务队列<br>在浏览器环境中，有 JS 引擎线程和渲染线程，且两个线程互斥。 Node 环境中，只有 JS 线程。 不同环境执行机制有差异，不同任务进入不同 Event Queue 队列。 当主程结束，先执行准备好微任务，然后再执行准备好的宏任务，一个轮询结束。</p><p>浏览器中的事件环（Event Loop)</p><p><img data-src="https://user-images.githubusercontent.com/12165373/129468098-f75d76f6-ad01-4390-a155-7fcd179f6a07.gif" alt="eventLoop"><br>事件环的运行机制是，先会执行栈中的内容，栈中的内容执行后执行微任务，微任务清空后再执行宏任务，先取出一个宏任务，再去执行微任务，然后在取宏任务清微任务这样不停的循环。</p><p>eventLoop 是由 JS 的宿主环境（浏览器）来实现的；</p><p>事件循环可以简单的描述为以下四个步骤:</p><ol><li>函数入栈，当 Stack 中执行到异步任务的时候，就将他丢给 WebAPIs, 接着执行同步任务，直到 Stack 为空；</li><li>此期间 WebAPIs 完成这个事件，把回调函数放入队列中等待执行（微任务放到微任务队列，宏任务放到宏任务队列）</li><li>执行栈为空时，Event Loop 把微任务队列执行清空；</li><li>微任务队列清空后，进入宏任务队列，取队列的第一项任务放入 Stack (栈）中执行，执行完成后，查看微任务队列是否有任务，有的话，清空微任务队列。重复 4，继续从宏任务中取任务执行，执行完成之后，继续清空微任务，如此反复循环，直至清空所有的任务。<br><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/342e581223d2471d9484fc48beb9f8e1~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="eventLoop"></li></ol><p>Node 是基于 V8 引擎的运行在服务端的 JavaScript 运行环境，在处理高并发、I/O 密集 (文件操作、网络操作、数据库操作等) 场景有明显的优势。虽然用到也是 V8 引擎，但由于服务目的和环境不同，导致了它的 API 与原生 JS 有些区别，其 Event Loop 还要处理一些 I/O，比如新的网络连接等，所以 Node 的 Event Loop (事件环机制) 与浏览器的是不太一样。<br><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e362c1770f62428fbf3faabd99d2a64c~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="eventLoop"></p><p><code>相关API</code><br><code>浏览器：</code><br>宏任务：setTimeout、setInterval、requestAnimationFrame<br>微任务：promise.then（async/await）、MutationObserver<br><code>Node：</code><br>宏任务：setTimeout、setInterval、setImmediate、I/O<br>微任务：promise.then（async/await）、process.nextTick</p><p><code>区别</code><br>node 环境下定时器时依次一起执行的，而浏览器是一个个分开的，有单独的线程处理<br>浏览器的微任务执行是在每个宏任务之后，而 node 中则是在按阶段执行，一个阶段一轮回</p></div></details><details class="warning"><summary>如何做到并发请求</summary><div><p>Promise.all 或者 web worker</p></div></details><details class="warning"><summary>Window.onLoad和DOMContentLoaded事件执行优先级</summary><div><p>dom 树构建完成时执行 DOMContentLoaded，然后页面挂载时执行 Window.onLoad。</p></div></details><h2 id="typescript"><a class="anchor" href="#typescript">#</a> TypeScript</h2><details class="info"><summary>Interface 和 Type区别</summary><div><p>相同点</p><ol><li>Interface 和 Type 描述的类型都可以被 class 实现。</li><li>Interface 和 Type 都可以扩展类型。但 interface 的实现方式是 extends，Type 则是用交叉类型的方式，extends 中的同名字段的类型必须是兼容的。而交叉类型中出现了同名字段且类型不同时，则类型一般是 never。</li></ol><p>不同点</p><ol><li>interface 只能描述对象，适用于接口类型校验，type 则是可以定义任何类型</li><li>Interface 可以重载、而 Type 不可重复定义。</li><li>Type 可以使用 in 关键字动态生成属性，而 Interface 的索引值必须是 string 或 number 类型，所以 Interface 并不支持动态生成属性。</li></ol></div></details><h2 id="框架"><a class="anchor" href="#框架">#</a> 框架</h2><h3 id="vue"><a class="anchor" href="#vue">#</a> Vue</h3><details class="success"><summary>Object.defineProperty有什么缺陷</summary><div><ol><li>无法监听数组下标引起的改变、对象新增属性</li><li>需要深度遍历整个 dom 树为每个节点添加 getter 和 setter</li></ol></div></details><details class="success"><summary>Vue双向数据绑定</summary><div><p>Vue2 采用 Object.defineProperty 为虚拟 dom 对象的每个属性添加 getter 和 setter 方法（观察者模式）<br>Vue3 采用 Proxy 做数据代理，相当于有一面墙在一个对象外，每次读写都会穿过这一面墙进行 get、set</p></div></details><details class="success"><summary>Vue3diff算法（虚拟dom、keys原理与下面react相同）</summary><div><p>vue2 中 diff 算法对虚拟 dom 进行全量对比，而 3 中新增了静态标记（PatchFlag），在与旧树对比时只对比带有标记的节点（如模板语法节点）。<br>所以说 vue2 中每次都要重新创建元素，而 vue3 只需要对不参与更新的元素创建一次，之后不断复用<br>优化静态 slot，使其父级元素改变时 slot 不做重渲染<br>事件缓存</p></div></details><details class="success"><summary>Vue的生命周期（vue3）</summary><div><p><img data-src="https://cn.vuejs.org/assets/lifecycle.16e4c08e.png" alt="Vue生命周期"></p></div></details><details class="success"><summary>v-if和v-show区别、v-if和v-for执行顺序</summary><div><p>v-if 控制 dom 有无，v-show 控制节点属性 display:none<br>vue2 中 v-for &gt; v-if,v-for 套 v-if 可以用 computed 解决，v-if 套 v-for 可以用 template<br>vue3 中 v-if &gt; v-for</p></div></details><details class="success"><summary>vue组件通信</summary><div><ol><li>prop（父子）</li><li>emit（子传父）</li><li>provide/inject（多级向下）</li><li>mitt（组件间）</li><li>pinia（状态仓库）</li></ol></div></details><details class="success"><summary>Vue性能优化</summary><div><ol><li>事件代理</li><li>keep-alive 缓存组件</li><li>组件懒加载、图片懒加载、虚拟列表</li><li>防抖节流</li></ol></div></details><details class="success"><summary>nextTick的实现原理</summary><div><p>nextTick 会在 dom 更新循环结束后执行延迟回调，主要使用了任务队列，根据环境兼容性分别使用<br>Promise-&gt;MutationObserver-&gt;setImmediate-&gt;setTimeout</p></div></details><details class="success"><summary>Vue 中的 computed 是如何实现的</summary><div><p>computed 本身是通过代理的方式代理到组件实例上的，所以读取计算属性的时候，执行的是一个内部的 getter，而不是用户定义的方法。</p><p>computed 内部实现了一个惰性的 watcher，在实例化的时候不会去求值，其内部通过 dirty 属性标记计算属性是否需要重新求值。当 computed 依赖的任一状态（不一定是 return 中的）发生变化，都会通知这个惰性 watcher，让它把 dirty 属性设置为 true。所以，当再次读取这个计算属性的时候，就会重新去求值。</p></div></details><details class="success"><summary>v-if、v-show、v-html 的原理是什么，它是如何封装的？</summary><div><p>v-if 会调用 addIfCondition 方法，生成 vnode 的时候会忽略对应节点，render 的时候就不会渲染<br>v-show 会生成 vnode，render 的时候也会渲染成真实节点，只是在 render 过程中会在节点的属性中修改 show 属性值，也就是常说的 display<br>v-html 会先移除节点下的所有节点，调用 html 方法，通过 addProp 添加 innerHTML 属性，归根结底还是设置 innerHTML 为 v-html 的值</p></div></details><h3 id="react"><a class="anchor" href="#react">#</a> React</h3><details class="info"><summary>React 虚拟DOM、diff算法原理、keys 的作用是什么</summary><div><p>虚拟 DOM 本质是对象，通过遍历 dom 树克隆 dom 上的属性生成。操作对象比操作 dom 性能消耗更少</p><p>diff 算法是将新生成的虚拟 dom 树按树形结构比较旧树的同级元素，为每个组件状态中需要改变的 dom 节点标记为 dirty，并在事件循环结束时重新渲染<br>为了降低时间复杂度，React 和 Vue 的思路是基于以下两个假设条件，缩减递归迭代规模，将 Diff 算法的时间复杂度降低为 O (n)：<br>相同类型的组件产生相同的 DOM 结构，反之亦然。所以不同类型组件的结构不需要进一步递归 Diff。<br>同一层级的一组节点，可以通过唯一标识符进行区分。</p><p>keys 一般出现在 for 循环中，且每个 for 循环的 keys 是独立的，keys 是 react 追踪哪些列表中的元素被增删改的辅助标识，它保证一个 for 循环中某个元素的唯一性，使得 react 在进行 diff 算法时能更高效的进行比对，以确定哪些元素需要被增删改，keys 尽量不要用 index，否则删除节点时也会重新渲染整个列表</p></div></details><details class="info"><summary>React的生命周期</summary><div><p><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b5fa490ee4d948dba86a950bfe08dede~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="React生命周期"></p></div></details><details class="info"><summary>React为什么要废除componentWillMount componentWillUpdate 和componentWillReceiveProps</summary><div><p>react 分为 render phase 和 commit phase 的，而像 componentWillmount componentWillUpdate 和 componentWillReceiveProps 等几个生命周期函数（包括 render）都是属于 render phase 的，在 fiber 机制提出前，render phase 阶段是不可被打断的（同步渲染），但是同步渲染会有体验问题，比如有几千个组件在渲染时，用户是没办法和浏览器进行交互的（js 线程被占用）。在 fiber 机制提出后，render phase 阶段可被打断，被打断后再次执行（优先级别），就会有以上提到的几个生命周期函数被多次调用。所以被废弃掉。componentwillmount 这个生命周期函数之前，有很多程序猿在里面写一些有副作用的 code，比如 ajax 调用，但这种做法 react 官方是不推荐的。可是又不能禁止。看 16.7 之后，它推出的新的生命周期 getDerivedStateFromProp 函数，就是一个 static 函数，在里面拿不到 this 也无法 setstate，更符合纯函数的概念。</p></div></details><details class="info"><summary>React常用的hook有哪些</summary><div><p>参考站内贴子 (<a href="https://evilmood.github.io/mublog/react/hook/">https://evilmood.github.io/mublog/react/hook/</a>)</p></div></details><details class="info"><summary>React的事件代理机制（react17事件合成机制）</summary><div><p>React 中的事件代理并非和原生一样（为了解决跨浏览器兼容），而是采用合成事件（SyntheticEvent），将事件绑定冒泡到根节点（16 是 document）统一管理</p><p>实现合成事件主要为了：<br>解决浏览器兼容问题，并且支持跨端开发<br>对于原生浏览器事件来说绑定一个事件则创建一个事件对象，如果有多个事件监听则会分配很多事件对象，造成高额的内存分配问题，合成事件则采用事件池专门管理事件的创建与销毁<br>具体可以看这条链接<br><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82OTU1NjM2OTExMjE0MDY3NzIwI2hlYWRpbmctMQ==">https://juejin.cn/post/6955636911214067720#heading-1</span></p></div></details><details class="info"><summary>说一下 react-fiber</summary><div><p>也可参考站内贴子 (<a href="https://evilmood.github.io/mublog/react/Fiber%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/">https://evilmood.github.io/mublog/react/Fiber 架构解析 /</a>)</p></div></details><details class="info"><summary>React setState是同步还是异步？</summary><div><p>setState 会根据场景的不同来决定，通过 isBathingUpdates 来判断 setState 是先存进 state 队列还是直接更新。在 react 可以控制的地方，如生命周期事件和合成事件，都会走合并操作延迟更新，而无法控制的地方，如原生事件中就走的同步操作</p></div></details><details class="info"><summary>React性能优化</summary><div><p>主要方向有以下几个</p><ol><li>减少组件重新渲染（memo）</li><li>缓存状态和函数（useMemo、useCallback）</li><li>长列表懒加载（虚拟列表），组件懒加载、图片懒加载</li></ol></div></details><details class="info"><summary>React组件通信方式</summary><div><ol><li>props（父传子、子传父 [回调函数]）</li><li>useImperativeHandle（子传父）</li><li>Context（多级往下）</li><li>mitt（两个组件间）</li><li>mobx、recoil（状态仓库）</li></ol></div></details><h3 id="框架综合"><a class="anchor" href="#框架综合">#</a> 框架综合</h3><details class="info"><summary>Vue和React区别</summary><div><p>状态：Vue 采用 Proxy 做数据代理监听每个状态的变换；React 默认通过比较引用（diff）进行，因此 react 需要绑定很多的 memo、useMemo、useCallback 做缓存处理<br>主要是 react 更强调数据不可变以及单向数据流，而 vue 强调可变数据以及数据的双向绑定，<br>渲染：Vue 再渲染时会跟踪每一个组件的依赖关系，不需要重新渲染整个渲染树，React 在渲染时则会直接渲染该组件以及其子组件</p></div></details><details class="info"><summary>React和Vue的diff算法时间复杂度从O(n^3^)降到O(n)，是如何计算出来的？</summary><div><ol><li>如果父节点不同，放弃对子节点的比较，直接删除旧节点，然后添加新的节点重新渲染</li><li>如果子节点有变化，VirtualDom 不会计算而是重新渲染</li><li>通过 key 唯一策略</li></ol></div></details><details class="info"><summary>框架如何优化首页的加载速度？首页白屏是什么问题引起的？如何解决呢？</summary><div><p>首页加载过慢，其原因是因为它是一个单页应用，需要将所有需要的资源都下载到浏览器端并解析。<br>解决办法</p><ol><li>使用首屏 SSR + 跳转 SPA 方式来优化</li><li>改单页应用为多页应用，需要修改 webpack 的 entry</li><li>改成多页以后使用应该使用 prefetch 的就使用</li><li>处理加载的时间片，合理安排加载顺序，尽量不要有大面积空隙</li><li>CDN 资源还是很重要的，最好分开，也能减少一些不必要的资源损耗</li><li>使用 Quicklink，在网速好的时候 可以帮助你预加载页面资源</li><li>骨架屏这种的用户体验的东西一定要上，最好借助 stream 先将这部分输出给浏览器解析</li><li>合理使用 web worker 优化一些计算</li><li>缓存一定要使用，但是请注意合理使用</li><li>可以借助一些工具进行性能评测，重点调优，例如使用 performance 自己实现下等</li></ol></div></details><details class="info"><summary>路由概念，前端路由与后端路由区别</summary><div><p>路由（routing）就是通过互联的网络把信息从源地址传输到目的地址的活动。 —— 维基百科</p><p>对于 Web 开发来说，路由的实质是 URL 到对应的处理程序的映射。Web 路由既可以由服务端，也可以由前端实现。<br>其中前端路由根据实现方式的不同，可以分为 Hash 路由 和 History 路由。</p><p>前端路由对于服务端路由来说，最显著的特点是页面可以在无刷新的情况下进行页面的切换。基于前端路由的这一特点，诞生了一种无刷新的单页应用开发模式 SPA。SPA 通过前端路由避免了页面的切换打断用户体验，让 Web 应用的体验更接近一个桌面应用程序。</p></div></details><details class="info"><summary>单页面应用(SPA)的优缺点</summary><div><p>优点：1、利用 ajax 技术，前后端分离，实现数据局部获取渲染 2、基于动态路由，页面转换时可以自定义动画，记录 location<br>缺点：1、不利于 seo 2、没有路由导航 3、资源大，加载耗时长，首屏问题（可以用组件懒加载解决）</p></div></details><details class="info"><summary>路由中hash和history的原理</summary><div><p><code>Hash特点</code></p><ol><li>hash 通过 window.onhashchange 的方式，来监听 hash 的改变，借此实现无刷新页面切换的功能。</li><li>hash 变化会改变浏览器的历史记录。</li><li>hash 不会触发页面重新加载（hash 的改变是记录在 window.history 中），所有页面的跳转都是在客户端进行操作，永远不会提交到 server 端（可以理解为只在前端自生自灭）。因此，这并不算是一次 http 请求，所以这种模式不利于 SEO 优化。hash 只能修改 # 后面的部分，所以只能跳转到与当前 url 同文档的 url 。</li></ol><p>优点：兼容性好，无需服务端配置<br>缺点：服务端无法获取 hash 部分内容、可能和锚点功能冲突、SEO 不友好。</p><p><code>History特点</code></p><ol><li>history API 是 H5 提供的新特性，允许开发者通过 pushState 、 replaceState 来实现无刷新跳转的功能。</li><li>新的 url 可以是与当前 url 同源的任意 url ，也可以是与当前 url 一样的地址，但是这样会导致的一个问题是，会把重复的这一次操作记录到栈当中。</li><li>通过 history.state ，添加任意类型的数据到记录中。</li></ol><p>优点：服务端可获取完整的链接和参数、前端监控友好、SEO 相对 Hash 路由友好。<br>缺点：兼容性稍弱、需要服务端额外配置（各 path 均指向同一个 HTML）。</p><p><code>两者的差别</code><br>使用 history 模式时，在对当前的页面进行刷新时，此时浏览器会重新发起请求。如果 nginx 没有匹配得到当前的 url ，就会出现 404 的页面。<br>而对于 hash 模式来说， 它虽然看着是改变了 url ，但不会被包括在 http 请求中。所以，它算是被用来指导浏览器的动作，并不影响服务器端。因此，改变 hash 并没有真正地改变 url ，所以页面路径还是之前的路径， nginx 也就不会拦截。<br>因此，在使用 history 模式时，需要通过服务端来允许地址可访问，如果没有设置，就很容易导致出现 404 的局面。</p></div></details><details class="info"><summary>路由权限的实现</summary><div><p>权限管理一般需求是页面权限和按钮权限的管理</p><p>具体实现的时候分后端和前端两种方案：<br>前端方案会把所有路由信息在前端配置，通过路由守卫要求用户登录，用户登录后根据角色过滤出路由表。比如我会配置一个 asyncRoutes 数组，需要认证的页面在其路由的 meta 中添加一个 roles 字段，等获取用户角色之后取两者的交集，若结果不为空则说明可以访问。此过滤过程结束，剩下的路由就是该用户能访问的页面，最后通过 router.addRoutes (accessRoutes) 方式动态添加路由即可。<br>后端方案会把所有页面路由信息存在数据库中，用户登录的时候根据其角色查询得到其能访问的所有页面路由信息返回给前端，前端再通过 addRoutes 动态添加路由信息<br>按钮权限的控制通常会实现一个指令，例如 v-permission，将按钮要求角色通过值传给 v-permission 指令，在指令的 moutned 钩子中可以判断当前用户角色和按钮是否存在交集，有则保留按钮，无则移除按钮。</p><p>纯前端方案的优点是实现简单，不需要额外权限管理页面，但是维护起来问题比较大，有新的页面和角色需求就要修改前端代码重新打包部署；服务端方案就不存在这个问题，通过专门的角色和权限管理页面，配置页面和按钮权限信息到数据库，应用每次登陆时获取的都是最新的路由信息，可谓一劳永逸！</p></div></details><details class="info"><summary>如果让你从零开始写一个vue路由，说说你的思路</summary><div><ul><li>借助 hash 或者 history api 实现 url 跳转页面不刷新</li><li>同时监听 hashchange 事件或者 popstate 事件处理跳转</li><li>根据 hash 值或者 state 值从 routes 表中匹配对应 component 并渲染之</li></ul><p>一个 SPA 应用的路由需要解决的问题是页面跳转内容改变同时不刷新，同时路由还需要以插件形式存在，所以：</p><p>首先我会定义一个 createRouter 函数，返回路由器实例，实例内部做几件事：</p><ol><li>保存用户传入的配置项</li><li>监听 hash 或者 popstate 事件</li><li>回调里根据 path 匹配对应路由</li></ol><p>将 router 定义成一个 Vue 插件，即实现 install 方法，内部做两件事：</p><p>实现两个全局组件：router-link 和 router-view，分别实现页面跳转和内容显示<br>定义两个全局变量：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>o</mi><mi>u</mi><mi>t</mi><mi>e</mi><mtext>和</mtext></mrow><annotation encoding="application/x-tex">route和</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.02778em">r</span><span class="mord mathnormal">o</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord cjk_fallback">和</span></span></span></span> router，组件内可以访问当前路由和路由器实例</p></div></details><details class="info"><summary>vue路由执行顺序</summary><div><ol><li>导航被触发 -&gt; 在失活的组件里调用 beforeRouteLeave 守卫 -&gt; 调用全局 beforeEach 前置守卫 -&gt; 重用的组件调用 beforeRouteUpdate 守卫 -&gt; 路由配置调用 beforeEnter-&gt; 解析异步路由组件 -&gt; 在被激活的组件里调用 beforeRouteEnter 守卫 -&gt; 调用全局的 beforeResolve 守卫 -&gt; 导航被确认 -&gt; 调用全局的 afterEach-&gt; 触发 DOM 更新 -&gt; 调用  beforeRouteEnter 守卫中传给 next 的回调函数，创建好的组件实例会作为回调函数的参数传入</li></ol></div></details><h2 id="web"><a class="anchor" href="#web">#</a> Web</h2><h3 id="dom"><a class="anchor" href="#dom">#</a> DOM</h3><h3 id="bom"><a class="anchor" href="#bom">#</a> BOM</h3><details class="warning"><summary>BOM中的各种位置</summary><div><p>layer：最近相对定位父级元素<br>clint：浏览器可视窗口（不包括控制台、菜单、滚动条、工具栏）<br>offset：浏览器可视窗口（包括上面这些）<br>scroll：目前可视窗口 + 滚动条离顶部或左边隐藏的部分<br>page：document 对象<br>screen：屏幕</p></div></details><h2 id="node"><a class="anchor" href="#node">#</a> Node</h2><details class="success"><summary>require 的模块加载机制</summary><div><ol><li>计算模块绝对路径</li><li>如果缓存中有该模块，则从缓存中取出该模块</li><li>按优先级依次寻找并编译执行模块，将模块推入缓存（require.cache）中</li><li>输出模块的 exports 属性</li></ol></div></details><details class="success"><summary>Node 更适合处理 I/O 密集型任务还是 CPU 密集型任务？为什么？</summary><div><p>Node 更适合处理 I/O 密集型的任务。因为 Node 的 I/O 密集型任务可以异步调用，利用事件循环的处理能力，资源占用极少。Javascript 是单线程的原因，Node 不适合处理 CPU 密集型的任务，CPU 密集型的任务会导致 CPU 时间片不能释放，使得后续 I/O 无法发起，从而造成阻塞。</p></div></details></div><footer><div class="meta"><span id="interview/JavaScript.html" class="item leancloud_visitors" data-flag-title="JavaScript与其框架" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/mublog/images/wechatpay.png" alt="EvilMoOd 微信支付"><p>微信支付</p></div><div><img data-src="/mublog/images/alipay.png" alt="EvilMoOd 支付宝"><p>支付宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>EvilMoOd <i class="ic i-at"><em>@</em></i>木糖不爱吃糖</li><li class="link"><strong>本文链接：</strong> <a href="https://evilmood.github.io/mublog/interview/JavaScript.html" title="JavaScript与其框架">https://evilmood.github.io/mublog/interview/JavaScript.html</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#javascript"><span class="toc-number">1.</span> <span class="toc-text">JavaScript</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80"><span class="toc-number">1.1.</span> <span class="toc-text">基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.1.</span> <span class="toc-text">数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83"><span class="toc-number">1.1.2.</span> <span class="toc-text">核心</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5%E6%9C%BA%E5%88%B6"><span class="toc-number">1.1.3.</span> <span class="toc-text">概念机制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#es6"><span class="toc-number">1.2.</span> <span class="toc-text">ES6</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F-%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE-%E9%97%AD%E5%8C%85-%E9%A2%84%E7%BC%96%E8%AF%91"><span class="toc-number">1.3.</span> <span class="toc-text">作用域、作用域链、闭包、预编译</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B-%E5%8E%9F%E5%9E%8B%E9%93%BE-%E7%BB%A7%E6%89%BF-this"><span class="toc-number">1.4.</span> <span class="toc-text">原型、原型链、继承、this</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B"><span class="toc-number">1.5.</span> <span class="toc-text">异步编程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#typescript"><span class="toc-number">2.</span> <span class="toc-text">TypeScript</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A1%86%E6%9E%B6"><span class="toc-number">3.</span> <span class="toc-text">框架</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#vue"><span class="toc-number">3.1.</span> <span class="toc-text">Vue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#react"><span class="toc-number">3.2.</span> <span class="toc-text">React</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%86%E6%9E%B6%E7%BB%BC%E5%90%88"><span class="toc-number">3.3.</span> <span class="toc-text">框架综合</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#web"><span class="toc-number">4.</span> <span class="toc-text">Web</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#dom"><span class="toc-number">4.1.</span> <span class="toc-text">DOM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bom"><span class="toc-number">4.2.</span> <span class="toc-text">BOM</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#node"><span class="toc-number">5.</span> <span class="toc-text">Node</span></a></li></ol></div><div class="related panel pjax" data-title="系列文章"></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="EvilMoOd" data-src="/mublog/images/avatar.jpg"><p class="name" itemprop="name">EvilMoOd</p><div class="description" itemprop="description">摸鱼是第一生产力</div></div><nav class="state"><div class="item posts"><a href="/mublog/archives/"><span class="count">27</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/mublog/categories/"><span class="count">15</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/mublog/tags/"><span class="count">25</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL0V2aWxNb09k" title="https:&#x2F;&#x2F;github.com&#x2F;EvilMoOd"><i class="ic i-github"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTM1Mzg4MjQ0Ng==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;353882446"><i class="ic i-cloud-music"></i></span> <span class="exturl item youtube" data-url="aHR0cHM6Ly9zcGFjZS5iaWxpYmlsaS5jb20vMjk2NDA4NDQ/c3BtX2lkX2Zyb209MzMzLjMzNy4wLjA=" title="https:&#x2F;&#x2F;space.bilibili.com&#x2F;29640844?spm_id_from&#x3D;333.337.0.0"><i class="ic i-youtube"></i></span></div><ul class="menu"><li class="item"><a href="/mublog/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/mublog/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/mublog/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/mublog/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-coffee"></i>品鉴</a><ul class="submenu"><li class="item"><a href="/mublog/games" rel="section"><i class="ic i-game"></i>电玩</a></li><li class="item"><a href="/mublog/movies" rel="section"><i class="ic i-play"></i>电影</a></li><li class="item"><a href="/mublog/books" rel="section"><i class="ic i-tag"></i>书架</a></li></ul></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-pen"></i>面筋</a><ul class="submenu"><li class="item"><a href="/mublog/interview/Network" rel="section"><i class="ic i-coffee"></i>Network</a></li><li class="item"><a href="/mublog/interview/HTML" rel="section"><i class="ic i-coffee"></i>HTML</a></li><li class="item"><a href="/mublog/interview/CSS" rel="section"><i class="ic i-coffee"></i>CSS</a></li><li class="item"><a href="/mublog/interview/JavaScript" rel="section"><i class="ic i-coffee"></i>JavaScript</a></li><li class="item"><a href="/mublog/interview/engineer" rel="section"><i class="ic i-coffee"></i>工程化</a></li></ul></li><li class="item"><a href="https://evilmood.github.io/" rel="section"><i class="ic i-user"></i>关于</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/mublog/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="分类于 计算机网络">计算机网络</a></div><span><a href="/mublog/core/%E7%BD%91%E8%B7%AF%E6%94%BB%E5%87%BB/" title="网络攻击">网络攻击</a></span></li><li class="item"><div class="breadcrumb"><a href="/mublog/categories/react/" title="分类于 react">react</a></div><span><a href="/mublog/react/Fiber%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/" title="Fiber架构解析">Fiber架构解析</a></span></li><li class="item"><div class="breadcrumb"><a href="/mublog/categories/%E5%BB%BA%E7%AB%99%E6%97%A5%E5%BF%97/" title="分类于 建站日志">建站日志</a></div><span><a href="/mublog/blog/%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%AE%A2%E4%B9%8B%E5%90%8E%E7%9A%84%E6%9B%B4%E6%96%B0/" title="关于博客之后的更新">关于博客之后的更新</a></span></li><li class="item"><div class="breadcrumb"><a href="/mublog/categories/%E4%B8%AA%E4%BA%BA%E6%9D%82%E8%B0%88/" title="分类于 个人杂谈">个人杂谈</a></div><span><a href="/mublog/talk/%E5%89%8D%E7%AB%AF%E5%85%A5%E5%9D%91%E6%8C%87%E5%8D%97/" title="前端入坑指南">前端入坑指南</a></span></li><li class="item"><div class="breadcrumb"><a href="/mublog/categories/core/" title="分类于 程序员核心知识">程序员核心知识</a></div><span><a href="/mublog/core/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" title="正则表达式攻略">正则表达式攻略</a></span></li><li class="item"><div class="breadcrumb"><a href="/mublog/categories/react/" title="分类于 react">react</a></div><span><a href="/mublog/react/hook/" title="React hook汇总">React hook汇总</a></span></li><li class="item"><div class="breadcrumb"><a href="/mublog/categories/JavaScript/" title="分类于 JavaScript">JavaScript</a></div><span><a href="/mublog/JavaScript/%E6%B7%B1%E5%85%A5%E5%8E%9F%E5%9E%8B/" title="深入原型&amp;继承&amp;this">深入原型&继承&this</a></span></li><li class="item"><div class="breadcrumb"><a href="/mublog/categories/CSS/" title="分类于 CSS">CSS</a></div><span><a href="/mublog/CSS_/CSS%E6%A0%B7%E5%BC%8F%E9%87%8D%E7%BD%AE/" title="CSS样式重置">CSS样式重置</a></span></li><li class="item"><div class="breadcrumb"><a href="/mublog/categories/Vue/" title="分类于 Vue">Vue</a></div><span><a href="/mublog/util/%E8%A7%A3%E5%86%B3VSCode%E4%B8%8B%E4%BD%BF%E7%94%A8vue%E6%8A%A5%E9%94%99%E6%89%BE%E4%B8%8D%E5%88%B0%E6%A8%A1%E5%9D%97%E6%88%96%E5%85%B6%E7%9B%B8%E5%BA%94%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E/" title="解决VSCode下使用vue报错找不到模块“.&#x2F;App.vue”或其相应的类型声明">解决VSCode下使用vue报错找不到模块“./App.vue”或其相应的类型声明</a></span></li><li class="item"><div class="breadcrumb"><a href="/mublog/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/" title="分类于 开发工具">开发工具</a></div><span><a href="/mublog/util/VSCode%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90/" title="VSCode插件推荐">VSCode插件推荐</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2022 – <span itemprop="copyrightYear">2025</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">EvilMoOd @ Evil MoOd</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">82k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">1:14</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"interview/JavaScript",favicon:{show:"（●´3｀●）嗯？Yeah~",hide:"(´Д｀)WTF?"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/mublog/js/app.js?v=0.2.5"></script><script src="/mublog/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/mublog/live2dw/assets/wanko.model.json"},display:{position:"right",width:150,height:300},mobile:{show:!0},react:{opacity:.7},log:!1})</script></body></html>