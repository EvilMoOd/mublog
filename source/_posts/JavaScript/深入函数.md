---
title: 深入函数
date: 2022/10/01
categories:
 - [JavaScript]
tags:
 - 函数
sticky: true
description: "用代码输出深入函数作用域、作用域链、闭包与预编译"
---

```js
function t(a) {
  console.log(a);
  var a = 1 //var本质也是按照下面的预编译过程来进行编译，但重复var声明不会报错
  console.log(a);
  // function a() {}
}
t(2)
// 2,1
// Function a 1（解开注释）
```

:::danger no-icon
函数预编译，顺序为

1. let a
2. 将形参赋值给a
3. 将函数声明赋值给a

:::

```js
 var a = 3;
 function c(){
    console.log(a);
 }
 (function(){
  var a = 4;
  c();
 })();
```

:::danger no-icon
js中变量的作用域链与定义时的环境有关，与执行时无关。执行环境只会改变this、传递的参数、全局变量等
:::

```js
function fun(n, o) {
  console.log(o)
  return {
    fun: function(m){
      return fun(m, n);
    }
  };
}
var a = fun(0);  a.fun(1);  a.fun(2);  a.fun(3);//undefined  0  0  0
var b = fun(0).fun(1).fun(2).fun(3);//undefined  0  1  2
var c = fun(0).fun(1);  c.fun(2);  c.fun(3);//undefined  0  1  1
```

:::danger no-icon
涉及闭包和作用域
fun返回一个对象
a不断调用a上的fun方法，该方法为fun函数，有点递归的意思，但由于每次都只传入第一次运行时闭包的n（0），所以每次输出0
b每次返回一个新对象来链式调用，新对象的n默认为上一个对象调用方法时传入的参数m
c调用两次函数，返回两次对象，后两次为调用方法，所以对象上形参n一直是1
:::

```js
f = function() {return true;};   
g = function() {return false;};   
(function() {   
   if (g() && [] == ![]) {   
      f = function f() {return false;};   
      // function g() {return true;}
   }   
  function g() {return true;}
})();   
console.log(f());
// false
```

:::danger no-icon
考察预编译
一次执行函数中的g()会预编译，所以此时if为真，执行语句，此时f被重新赋值，所以输出false
注意如果g函数写在if中，g还是会预编译，在一次执行函数的作用域执行 var g，但值为undefined，不会运行预编译第二步将函数声明提升，此时在if判断时执行g()时会报错g is not a function
:::
