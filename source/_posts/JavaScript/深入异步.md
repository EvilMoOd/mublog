---
title: 深入异步
date: 2022/10/01
categories:
 - [JavaScript]
tags:
 - 异步编程
sticky: true
description: "通过代码输出，解析异步编程代码的运行顺序，深入异步编程包括EvenLoop事件队列、宏任务、微任务等，理解Promise、async/await"
---

## Promise

### 状态

```js
const promise = new Promise((resolve, reject) => {
  console.log(1);
  console.log(2);
});
promise.then(() => {
  console.log(3);
});
console.log(4);
// 输出 1、2、4
```

:::warning no-icon
Promise只有三种状态，Pending、Resolve、Reject，上面代码一直处于Pending，所以then不会被执行，
new Promise中的代码也算是同步代码
:::

```js
const promise1 = new Promise((resolve, reject) => {
  console.log('promise1')
  resolve('resolve1')
})
const promise2 = promise1.then(res => {
  console.log(res)
  // return 'resolve2'
})
console.log('1', promise1);
console.log('2', promise2);
// setTimeout(() => {
//   console.log(promise2);
//   promise2.then((res) => {
//     console.log(res)
//   })
// }, 1);

/* 
输出
promise1
1 Promise{<resolved>: resolve1}
2 Promise{<pending>}
resolve1
解开注释后的代码输出（对应下面括号中的解释）
promise1
1 Promise { 'resolve1' }
2 Promise { <pending> }
resolve1
Promise { 'resolve2' }
resolve2
 */
```

:::warning no-icon
按顺序执行，输出1时promise1已经变为resolve状态，输出2时promise2还是pending(因为then中未return，如果return则将返回一个新的promise包装return值且promise状态为resolve)
执行完同步代码后执行微任务then(即便then中return也无法改变上面结果，因为promise2的状态改变是在同步代码执行完后的下一个微任务中)
:::

```js
const promise = new Promise((resolve, reject) => {
    resolve('success1');
    reject('error');
    resolve('success2');
});
promise.then((res) => {
    console.log('then:', res);
}).catch((err) => {
    console.log('catch:', err);
})
// 输出：
// then：success1
```

:::warning no-icon
promise状态不可逆
:::

### 链式调用

```js
Promise.resolve(1)
  .then(2)
  .then(Promise.resolve(3))
  .then(console.log)
  // 1

Promise.resolve(1)
  .then(2)
  .then(() => Promise.resolve(3))
  .then(console.log)
  // 3
```

:::warning no-icon
then方法接受的参数是函数，而如果传递的并非是一个函数，它实际上会将其解释为then(null)，这就会导致前一个Promise的结果会传递下面。
Promise.resolve(3)是一个对象
:::

```js
Promise.resolve().then(() => {
  return new Error('error!!!')
}).then(res => {
  console.log("then: ", res)
  return 1
}).catch(err => {
  console.log("catch: ", err)
}).then(res => {
  console.log(res)
})
// 输出
// "then: " "Error: error!!!"
// 1
```

:::warning no-icon
容易搞错的地方在于这里是return而非throw
then之后会穿透catch执行下一个then
:::

```js
const promise = Promise.resolve().then(() => {
  return promise;
})
promise.catch(console.err)
// Uncaught (in promise) TypeError: Chaining cycle detected for promise #<Promise>
```

:::warning no-icon
不要返回自身，否则会循环
:::

```js
Promise.reject('err!!!')
  .then((res) => {
    console.log('success', res)
  }, (err) => {
    console.log('error', err)
  }).catch(err => {
    console.log('catch', err)
  })
  // error err!!!
```

:::warning no-icon
这里直接被then的第二个参数拦截捕获了，也就不会执行catch（then函数中的两个参数：第一个参数是用来处理Promise成功的函数，第二个则是处理失败的函数）
:::

```js
Promise.resolve('1')
  .then(res => {
    console.log(res)
  })
  .finally(() => {
    console.log('finally')
  })
Promise.resolve('2')
  .finally(() => {
    console.log('finally2')
   return '我是finally2返回的值'
  })
  .then(res => {
    console.log('finally2后面的then函数', res)
  })
/* 
1
finally2
finally
finally2后面的then函数 2
 */

Promise.resolve('1')
  .finally(() => {
    console.log('finally1')
    throw new Error('我是finally中抛出的异常')
  })
  .then(res => {
    console.log('finally后面的then函数', res)
  })
  .catch(err => {
    console.log('捕获错误', err)
  })

/* 
'finally1'
'捕获错误' Error: 我是finally中抛出的异常
*/
```

:::warning no-icon
finally不接受任何参数，默认会把上一个promise状态的值return传递下去，且不可通过人为return改变，只能通过throw改变
:::

```js
function runAsync (x) {
  const p = new Promise(r => setTimeout(() => r(x, console.log(x)), 1000))
  return p
}
function runReject (x) {
  const p = new Promise((res, rej) => setTimeout(() => rej(`Error: ${x}`, console.log(x)), 1000 * x))
  return p
}
Promise.all([runAsync(1), runReject(4), runAsync(3), runReject(2)])
       .then(res => console.log(res))
       .catch(err => console.log(err))

/* 
// 1s后输出
1
3
// 2s后输出
2
Error: 2
// 4s后输出
4
*/
```

:::warning no-icon
这里主要注意：
catch只触发一次
且Promise.all抛出reject时，runReject(4)函数仍然在执行
另外如果在then函数中添加第二个参数，则会拦截执行使后面的catch不会执行，且只执行一次，因为promise状态改变已触发链式调用，后续Promise.all的结果并不会再次触发链式调用(race方法或any方法也是)
:::

### async/await

```js
async function async1() {
  console.log("async1 start");
  await async2();
  console.log("async1 end");
}
async function async2() {
  console.log("async2");
}
async1();
console.log('start')

/* 
async1 start
async2
start
async1 end
*/
```

:::warning no-icon
这里可以理解为await后面的语句相当于放到了new Promise中（不同点在于这个promise会在运行完代码后自动resolve或reject，除非async2手动new Promise），下一行及之后的语句相当于放在Promise.then中。
:::

```js
async function async1() {
  console.log("async1 start");
  await async2();
  console.log("async1 end");
  setTimeout(() => {
    console.log('timer1')
  }, 0)
}
async function async2() {
  setTimeout(() => {
    console.log('timer2')
  }, 0)
  console.log("async2");
}
async1();
setTimeout(() => {
  console.log('timer3')
}, 0)
console.log("start")

/* 
async1 start
async2
start
async1 end
timer2
timer3
timer1
*/
```

:::warning no-icon
宏任务微任务练习题，then是微任务，定时器是宏任务，执行顺序为同步代码->微任务->宏任务，且注意定时器运行顺序即为添加顺序
:::

```js
async function async1 () {
  console.log('async1 start');
  await new Promise(resolve => {
    console.log('promise1')
  })
  console.log('async1 success');
  return 'async1 end'
}
console.log('srcipt start')
async1().then(res => console.log(res))
console.log('srcipt end')

/* 
script start
async1 start
promise1
script end
*/
```

:::warning no-icon
上面说过await 可以当作new Promise，而await后面的代码则可以当作then，该代码中promise以及async1的状态一直是pending，所以await后面代码以及下面的then不会执行
promise的状态改变需要resolve触发，async1需要return 触发
:::

### 宏任务和微任务

```js
console.log(1)

setTimeout(() => {
  console.log(2)
})

new Promise(resolve =>  {
  console.log(3)
  resolve(4)
}).then(d => console.log(d))

setTimeout(() => {
  console.log(5)
  new Promise(resolve =>  {
    resolve(6)
  }).then(d => console.log(d))
})

setTimeout(() => {
  console.log(7)
})

console.log(8)
/* 
1
3
8
4
2
5
6
7
*/
```

:::warning no-icon
浏览器的EventLoop会在执行下一个宏任务之前清空当前的微任务
:::

```js
console.log('1');

setTimeout(function() {
    console.log('2');
    process.nextTick(function() {
        console.log('3');
    })
    new Promise(function(resolve) {
        console.log('4');
        resolve();
    }).then(function() {
        console.log('5')
    })
})
process.nextTick(function() {
    console.log('6');
})
new Promise(function(resolve) {
    console.log('7');
    resolve();
}).then(function() {
    console.log('8')
})

setTimeout(function() {
    console.log('9');
    process.nextTick(function() {
        console.log('10');
    })
    new Promise(function(resolve) {
        console.log('11');
        resolve();
    }).then(function() {
        console.log('12')
    })
})
/* 
1
7
6
8
2
4
3
5
9
11
10
12
*/
```

:::warning no-icon
nextTick也是微任务
:::
