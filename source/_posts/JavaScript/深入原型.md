---
title: 深入原型&继承&this
date: 2022/10/01
categories:
 - [JavaScript]
tags:
 - 原型
description: "判断代码输出结果，深入了解this指向和原型链关系"
---

## this指向

```js
function foo() {
  console.log( this.a );
}

function doFoo() {
  foo();
}

var obj = {
  a: 1,
  doFoo: doFoo
};

var a = 2; 
obj.doFoo()
// 2
```

:::success no-icon
obj调用doFoo方法，doFoo中执行foo函数，函数调用函数则当作由window（global）调用，所以this指向全局的a=2
:::

```js
var a = 10
var obj = {
  a: 20,
  say: () => {
    console.log(this.a)
  }
}
obj.say() 

var anotherObj = { a: 30 } 
obj.say.apply(anotherObj) 
// 10 10
```

:::success no-icon
obj调用say，但由于属性值为箭头函数（箭头函数没有this），所以不能作为obj上的方法调用，this指向上一层，上一层为window，是所以输出10
apply可以改变函数的this，但箭头函数无this，所以无法改变，仍是由全局调用
:::

```js
function a() {
  console.log(this);
}
a.call(null);
// window或global对象
```

:::success no-icon
根据ECMAScript262规范规定：如果第一个参数传入的对象调用者是null或者undefined，call方法将把全局对象（浏览器上是window对象）作为this的值。所以，不管传入null 还是 undefined，其this都是全局对象window或global。
要注意的是，在严格模式中，null 就是 null，undefined 就是 undefined
:::

```js
var obj = {
   say: function() {
     var f1 = () =>  {
       console.log("1111", this);
     }
     f1();
   },
   pro: {
     getPro:() =>  {
        console.log(this);
     }
   }
}
var o = obj.say;
o();
obj.say();
obj.pro.getPro();
/* 
1111 window（global）对象
1111 obj对象
{}
*/
```

:::success no-icon
o在全局调用，所以this是window或global
obj调用say方法，而say方法中执行fn箭头函数，可以认为是函数调函数，但由于箭头函数无this，指向上一层级，所以是obj调用，该处this指向obj
不同于上，这里是pro调用了getPro这个箭头函数，这里的this指向上一层级window（这里node中打印了空对象）（注意这里的上一层级并不是obj）
:::

```js
var obj = {
    foo: "bar",
    func: function() {
        var self = this;
        console.log(this.foo);  
        console.log(self.foo);  
        (function() {
            console.log(this.foo);  
            console.log(self.foo);  
        }());
    }
};
obj.func();
// bar bar undefined bar
```

:::success no-icon
在立即执行函数中，this指向全局（特别注意，并非有括号就是立即执行函数，(obj.func)()本质上还是obj.func(),this指向还是obj）
self通过作用域链找到func中的self，该self保存着this指向obj
:::

```js
var length = 10;
function fn() {
    console.log(this.length);
}
 
var obj = {
  length: 5,
  method: function(fn) {
    fn();
    arguments[0]();
  }
};
 
obj.method(fn, 1);
// 10 2
```

:::success no-icon
函数调函数，由全局调用
`arguments[0]()`可以看作`arguments.fn()` fn指向arguments
:::

```js
var x = 3;
var y = 4;
var obj = {
    x: 1,
    y: 6,
    getX: function() {
        var x = 5;
        return function() {
            return this.x;
        }();
    },
    getY: function() {
        var y = 7;
        return this.y;
    }
}
console.log(obj.getX()) // 3
console.log(obj.getY()) // 6
```

:::success no-icon
匿名函数的this是指向全局对象的，所以this指向window，会打印出3；
getY是由obj调用的，所以其this指向的是obj对象，会打印出6。
:::

```js
function a(xx){
  this.x = xx;
  return this
};
var x = a(5);
var y = a(6);

console.log(x.x)  // 6（浏览器为undefined）
console.log(y.x)  // 6
```

:::success no-icon
return this后，x和y都是global，global.x就是6
如果是在浏览器中，则代码运行顺序如下
window.x = 5 -> window.x = window -> window.x = 6 -> window.y = window
所以结果输出则为6.x（undefined），window.x（6）
:::

## 原型

```javascript
function Person(name) {
    this.name = name
}
var p2 = new Person('king');
console.log(p2.__proto__) //Person.prototype
console.log(p2.__proto__.__proto__) //Object.prototype
console.log(p2.__proto__.__proto__.__proto__) // null
console.log(p2.__proto__.__proto__.__proto__.__proto__)//null后面没有了，报错
console.log(p2.__proto__.__proto__.__proto__.__proto__.__proto__)//null后面没有了，报错
console.log(p2.constructor)//Person
console.log(p2.prototype)//undefined p2是实例，没有prototype属性
console.log(Person.constructor)//Function 一个空函数
console.log(Person.prototype)//打印出Person.prototype这个对象里所有的方法和属性
console.log(Person.prototype.constructor)//Person
console.log(Person.prototype.__proto__)// Object.prototype
console.log(Person.__proto__) //Function.prototype
console.log(Function.prototype.__proto__)//Object.prototype
console.log(Function.__proto__)//Function.prototype
console.log(Object.__proto__)//Function.prototype
console.log(Object.prototype.__proto__)//null
```

:::success no-icon
原型入门
:::

```js
function changeObjProperty(o) {
  o.name = "baidu"
  o = new Object()
  o.name = "byte"
} 
let company = new Object();
changeObjProperty(company);
console.log(company.name);

```

:::success no-icon
输出为baidu，传入参数为company，则此时变量o引用的是company，可以直接对对象进行操作，如果此时重新赋值new Object，那么此时o指向新建的对象，此时o再进行的操作都与company无关
:::

```js
function Person() {}
function Father() {}
Father.prototype = new Person()
const son = new Father()

```

:::success no-icon
指向Person，虽然在原型链上，但原型继承无法继承构造函数
:::
