---
title: HTML
description: "本模块主要包含HTML、网络和浏览器三大块知识，因为习惯三件套的说法，所以把后两者都归类到HTML中，实际上按内容来划分的话，网络>浏览器>HTML。"
---

## HTML

+++danger Doctype作用? 标准模式与兼容模式如何区分？
<!DOCTYPE> 声明位于文档中的最前面，处于html标签之前。告知浏览器以何种模式来渲染文档。
标准模式的排版和 JS 运作模式是 以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现。
+++

+++danger 语义化标签

1. 利于SEO
2. 提高代码可读性
+++

+++danger  说一下 HTML5 drag api
darg：事件主体是被拖放元素，在正在拖放被拖放元素时触发。
dragstart：事件主体是被拖放元素，在开始拖放被拖放元素时触发，。
dragend：事件主体是被拖放元素，在整个拖放操作结束时触发
dragenter：事件主体是目标元素，在被拖放元素进入某元素时触发。
dragover：事件主体是目标元素，在被拖放在某元素内移动时触发。
dragleave：事件主体是目标元素，在被拖放元素移出目标元素是触发。
drop：事件主体是目标元素，在目标元素完全接受被拖放元素时触发。
+++

+++danger attribute和property区别
前者是HTML文档属性，后者是JS 获取DOM属性
+++

## 网络

+++warning 七层模型和相关协议
应用层：允许访问OSI环境的手段（应用协议数据单元APDU）
表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）
会话层：建立、管理和终止会话（会话协议数据单元SPDU）
传输层：提供端到端的可靠报文传递和错误恢复（段Segment）
网络层：负责数据包从源到宿的传递和网际互连（包PackeT）
数据链路层：将比特组装成帧和点到点的传递（帧Frame）
物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）

ICMP协议： 因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。
TFTP协议： 是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。
HTTP协议： 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。
DHCP协议： 动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置参数手段。
+++

### HTTP

+++warning 谈谈网络性能优化

1. 避免请求：采用强缓存和协商缓存，DNS缓存，CDN负载均衡
2. 减少请求：1.资源的懒加载 2.合并请求，如将静态资源合并成一个大文件 3.代理重定向
3. 压缩：1.图片视频等资源进行有损压缩 2.代码文本类进行无损压缩（Gzip）
+++

#### HTTP各个版本

+++warning 简述HTTP各个版本改进
`HTTP2.0`

1. 二进制格式：HTTP2.0 基本单位为二进制，以往是采用文本形式，健壮性不是很好，现在采用二进制格式，更方便更健壮
2. 多路复用：把多个请求当做多个流，请求响应数据分成多个帧，不同流中的帧交错发送，解决了 TCP 连接数量多、慢和队头阻塞的问题，所以对于同一个域名只用创建一个连接就可以了
3. 压缩消息头：客户端和服务端共同维护一个字典，重复发送同样请求头时只需要发送索引即可
4. HTTP2.0 服务端推送，浏览器发送请求后，服务端会主动发送与这个请求相关的资源，之后浏览器就不用再次发送后续的请求了

`HTTP1.1`

1. 缓存处理新增 E-Tag、If-None-Match 之类的缓存来来控制缓存
2. 长连接，可以在一个 TCP 连接上发送多个请求和响应，但存在队头阻塞问题
+++

+++warning 谈谈HTTP2中的多路复用
在 HTTP1.1中即使开启了 Keep-Alive，解决了多次连接的问题，但是依然有两个效率上的问题：
一是服务端必须顺序响应文件，容易造成队头阻塞，二是连接数过多导致的性能问题。
HTTP2 的多路复用就是为了解决上述的两个性能问题。
在 HTTP/2 中，有两个非常重要的概念，分别是帧（frame）和流（stream）。帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流。
多路复用，就是在一个 TCP 连接中可以存在多条流。换句话说，也就是可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。通过这个技术，可以避免 HTTP 旧版本中的队头阻塞问题，极大的提高传输性能。
+++

#### HTTPS

+++warning SSL连接断开后如何恢复
Session id：通过将会话时产生的编号再一次传给服务器，若服务器有该记录则可以继续使用
Session Ticket：session ticket 是服务器在上一次对话中发送给客户的，这个 ticket 是加密的，只有服务器可能够解密，里面包含了本次会话的信息，比如对话密钥和加密方法等。这样不管我们的请求是否转移到其他的服务器上，当服务器将 ticket 解密以后，就能够获取上次对话的信息，就不用重新生成对话秘钥了。
+++

+++warning http 和 https 的区别及优缺点？

1. http 是超文本传输协议，信息是明文传输，HTTPS 协议要比 http 协议安全，https 是具有安全性的 ssl 加密传输协议，可防止数据在传输过程中被窃取、改变，确保数据的完整性(当然这种安全性并非绝对的，对于更深入的 Web 安全问题，此处暂且不表)。
2. http 协议的默认端口为 80，https 的默认端口为 443。
3. http 的连接很简单，是无状态的。https 握手阶段比较费时，会使页面加载时间延长 50%，增加 10%~20%的耗电。
4. https 缓存不如 http 高效，会增加数据开销。
5. Https 协议需要 ca 证书，费用较高，功能越强大的证书费用越高。
6. SSL 证书需要绑定 IP，不能再同一个 IP 上绑定多个域名，IPV4 资源支持不了这种消耗。
+++

### TCP/UDP/WebSocket

+++warning TCP三次握手四次挥手
`握手：`

1. 发送端发送SYN标志（我要发送请求）
2. 接收端回复一个SYN/ACK（ok收到，你发吧）
3. 发送端再回复ACK握手结束（ok）

`挥手`

1. 主动关闭方发送FIN（我要关闭请求了）【注意这里如果还有未完毕的请求（未收到对方ACK）会继续发送或接收】
2. 被关闭方回复ACK（知道了，等我这边处理请求完先）
3. 被关闭方发送FIN（处理完了，我也要关闭请求了）
4. 主动关闭方回复ACK（知道了）
:::warning no-icon
如果省略第三次握手，则遇到网络差的情况会阻塞导致再建立一条新的TCP握手请求，等到网络畅通时旧的网络请求会再工作导致bug
:::
+++

+++warning TCP和UDP的区别
TCP是面向有连接的协议，一对一、可靠、面向字节流
UDP是面向无连接的协议，一对多、不可靠、面向报文
+++

+++warning TCP/IP / 如何保证数据包传输的有序可靠？
对字节流分段并进行编号然后通过 ACK 回复和超时重发这两个机制来保证。

1. 为了保证数据包的可靠传递，发送方必须把已发送的数据包保留在缓冲区；
2. 并为每个已发送的数据包启动一个超时定时器；
3. 如在定时器超时之前收到了对方发来的应答信息（可能是对本包的应答，也可以是对本包后续包的应答），则释放该数据包占用的缓冲区;
4. 否则，重传该数据包，直到收到应答或重传次数超过规定的最大次数为止。
5. 接收方收到数据包后，先进行CRC校验，如果正确则把数据交给上层协议，然后给发送方发送一个累计应答包，表明该数据已收到，如果接收方正好也有数据要发给发送方，应答包也可方在数据包中捎带过去。

+++

+++warning 什么是粘包问题，如何解决？
简单得说，在流传输中出现，UDP不会出现粘包，因为它有消息边界
粘包情况有两种，一种是粘在一起的包都是完整的数据包，另一种情况是粘在一起的包有不完整的包。

为了避免粘包现象，可采取以下几种措施：

1. 对于发送方引起的粘包现象，用户可通过编程设置来避免，TCP提供了强制数据立即传送的操作指令push，TCP软件收到该操作指令后，就立即将本段数据发送出去，而不必等待发送缓冲区满；
2. 对于接收方引起的粘包，则可通过优化程序设计、精简接收进程工作量、提高接收进程优先级等措施，使其及时接收数据，从而尽量避免出现粘包现象；
3. 由接收方控制，将一包数据按结构字段，人为控制分多次接收，然后合并，通过这种手段来避免粘包。分包多发。
以上提到的三种措施，都有其不足之处。

`不足`

1. 第一种编程设置方法虽然可以避免发送方引起的粘包，但它关闭了Nagle优化算法，降低了网络发送效率，影响应用程序的性能，一般不建议使用。
2. 第二种方法只能减少出现粘包的可能性，但并不能完全避免粘包，当发送频率较高时，或由于网络突发可能使某个时间段数据包到达接收方较快，接收方还是有可能来不及接收，从而导致粘包。
3. 第三种方法虽然避免了粘包，但应用程序的效率较低，对实时应用的场合不适合。

一种比较周全的对策是：接收方创建一预处理线程，对接收到的数据包进行预处理，将粘连的包分开。实验证明这种方法是高效可行的。

+++

+++warning A、B 机器正常连接后，B 机器突然重启，问 A 此时处于 TCP 什么状态?
因为 B 会在重启之后进入 tcp 状态机的 listen 状态，只要当 a 重新发送一个数据包（无论是 syn 包或者是应用数据），b 端应该会主动发送一个带 rst 位的重置包来进行连接重置，所以 a 应该在 syn_sent 状态
+++

## 浏览器

### 机制

+++info 渲染机制、回流与重绘、如何避免

1. 浏览器采用流式布局模型（Flow Based Layout）；
2. 浏览器会把 HTML 解析成 DOM，把 CSS 解析成 CSSOM,DOM 和 CSSOM 合并就产生了渲染树（Render Tree）；
3. 有了 RenderTree，我们就知道了所有节点的样式，然后计算他们在页面上的大小和位置，最后把节点绘制到页面上；
4. 由于浏览器使用流式布局，对 Render Tree 的计算通常只需要遍历一次就可以完成，但 table 及其内部元素除外，他们可能需要多次计算，通常要花 3 倍于同等元素的时间，这也是为什么要避免使用 table 布局的原因之一；

`回流`
布局或者几何属性改变时触发回流。回流是影响浏览器性能的关键因素，因为其变化涉及到部分页面（或是整个页面）的布局更新。一个元素的回流可能会导致其素有子元素以及 DOM 中紧随其后的节点、祖先节点元素的随后的回流。大部分的回流将导致页面的重新渲染。回流必定会发生重绘，重绘不一定会引发回流。
`重绘`
由于节点的集合属性发生改变或者由于样式改变而不会影响布局的，成为重绘，例如 outline、visibility、color、background-color 等

减少回流和重绘

`CSS`

- 使用 transform 代替 top
- 使用 visibility 替换 display: none，前者引起重绘，后者引发回流
- 避免使用 table 布局
- 尽可能在 DOM 树的最末端改变 class
- 避免设置多层内联样式，CSS 选择符从右往左匹配查找，避免节点层级过多
- 将动画效果应用到 position 属性为 absolute 或 fixed 的元素上，避免影响其他元素的布局
- 避免使用 CSS 表达式，可能会引发回流
- CSS 硬件加速

`Javascript`

- 避免频繁操作样式，修改 class 最好
- 避免频繁操作 DOM，合并多次修改为一次
- 避免频繁读取会引发回流/重绘的属性，将结果缓存
- 对用户改变窗口的操作进行防抖处理
+++

+++info 说下进程、线程和协程
进程是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程，是操作系统进行资源分配和调度的一个独立单位，是应用程序运行的载体。进程是一种抽象的概念，从来没有统一的标准定义。

线程是程序执行中一个单一的顺序控制流程，是程序执行流的最小单元，是处理器调度和分派的基本单位。一个进程可以有一个或多个线程，各个线程之间共享程序的内存空间(也就是所在进程的内存空间)。一个标准的线程由线程ID、当前指令指针(PC)、寄存器和堆栈组成。而进程由内存空间(代码、数据、进程空间、打开的文件)和一个或多个线程组成。

协程是一种基于线程之上，但又比线程更加轻量级的存在，这种由程序员自己写程序来管理的轻量级线程叫做『用户空间线程』，具有对内核来说不可见的特性。

进程和线程的区别与联系
【区别】：
调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位；
并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行；
拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源。
系统开销：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销。但是进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个进程死掉就等于所有的线程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。
【联系】：
一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程；
资源分配给进程，同一进程的所有线程共享该进程的所有资源；
处理机分给线程，即真正在处理机上运行的是线程；
线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。

+++

+++info 父进程或子进程的死亡是否会影响对方? 什么是孤儿进程?僵尸进程?
子进程死亡不会影响父进程，不过子进程死亡时，会向它的父进程发送死亡信号。反之父进程死亡，一般情况下子进程也会随之死亡，但如果此时子进程处于可运行状态、僵死状态等等的话，子进程将被 init 进程收养，从而成为孤儿进程。
子进程死亡的时候（处于“终止状态”），父进程没有及时调用 wait() 或 waitpid() 来返回死亡进程的相关信息，此时子进程还有一个 PCB 残留在进程表中，被称为僵尸进程。
+++

### 网络相关

+++info 一个页面从输入URL到页面加载显示完成，这个过程中都发生了什么？
`请求：`

1. 浏览器会开启一个线程来处理这个请求，如果是关键字则启动对应搜索引擎。如果输入是url则按照`本地缓存->本地DNS服务器->根域名服务器->顶级域名服务器->权威域名服务器`顺序获取IP地址(用户向本地 DNS 服务器发起请求属于递归请求，本地 DNS 服务器向各级域名服务器发起请求属于迭代请求)。当浏览器得到 IP 地址后，数据传输还需要知道目的主机 MAC 地址，因为应用层下发数据给传输层，TCP 协议会指定源端口号和目的端口号，然后下发给网络层。网络层会将本机地址作为源地址，获取的 IP 地址作为目的地址。然后将下发给数据链路层，数据链路层的发送需要加入通信双方的 MAC 地址，本机的 MAC 地址作为源 MAC 地址，目的 MAC 地址需要分情况处理。通过将 IP 地址与本机的子网掩码相与，可以判断是否与请求主机在同一个子网里，如果在同一个子网里，可以使用 APR 协议获取到目的主机的 MAC 地址，如果不在一个子网里，那么请求应该转发给网关，由它代为转发，此时同样可以通过 ARP 协议来获取网关的 MAC 地址，此时目的主机的 MAC 地址应该为网关的地址。
2. 浏览器与远程 Web 服务器通过 TCP 三次握手协商来建立一个 TCP/IP 连接。该握手包括一个同步报文，一个同步-应答报文和一个应答报文，这三个报文在浏览器和服务器之间传递。该握手首先由客户端尝试建立起通信，而后服务器应答并接受客户端的请求，最后由客户端发出该请求已经被接受的报文。
3. 一旦 TCP/IP 连接建立，浏览器会通过该连接向远程服务器发送 HTTP 请求。远程服务器找到资源并使用HTTP响应返回该资源，值为200的HTTP响应状态表示一个正确的响应。
4. 如果使用的是 HTTPS 协议，在通信前还存在 TLS 的一个四次握手的过程。首先由客户端向服务器端发送使用的协议的版本号、一个随机数和可以使用的加密方法。服务器端收到后，确认加密的方法，也向客户端发送一个随机数和自己的数字证书。客户端收到后，首先检查数字证书是否有效，如果有效，则再生成一个随机数，并使用证书中的公钥对随机数加密，然后发送给服务器端，并且还会提供一个前面所有内容的 hash 值供服务器端检验。服务器端接收后，使用自己的私钥对数据解密，同时向客户端发送一个前面所有内容的 hash 值供客户端检验。这个时候双方都有了三个随机数，按照之前所约定的加密方法，使用这三个随机数生成一把会话秘钥，以后双方通信前，就使用这个会话秘钥对数据进行加密后再传输。
5. 此时， Web 服务器提供资源服务，客户端开始下载资源。

`渲染：`

1. 解析
解析收到的文档，根据文档构建一颗DOM树，DOM 树是由 DOM元素及属性节点组成的。
然后对 CSS 进行解析，生成CSSOM规则树
根据 DOM 树和 CSSOM 规则树构建 Render Tree。渲染树的节点被称为渲染对象，渲染对象是一个包含有颜色和大小等属性的矩形，渲染对象和DOM 对象相对应，但这种对应关系不是一对一的，不可见的 DOM 元素不会被插入渲染树。
下载JS脚本、图片等资源
2. 布局
接着就会根据渲染树来进行布局（也可以叫做回流）。这一阶段浏览器要做的事情就是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动重排”。
3. 绘制
布局阶段结束后是绘制阶段，比那里渲染树并调用对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组件。为了更好的用户体验，渲染引擎会尽可能早的将内容呈现到屏幕上，并不会等到所有的 html 解析完成之后再去构建和布局 render tree。它是解析完一部分内容就显示一部分内容，同时可能还在网络下载其余内容。

`JS引擎解析：`

1. 创建window对象：window对象也叫全局执行环境，当页面产生时就被创建，所有的全局变量和函数都属于window的属性和方法，而DOM Tree也会映射在window的doucment对象上。当关闭网页或者关闭浏览器时，全局执行环境会被销毁。
2. 加载文件：完成js引擎分析它的语法与词法是否合法，如果合法进入预编译
3. 预编译：在预编译的过程中，浏览器会寻找全局变量声明，把它作为window的属性加入到window对象中，并给变量赋值为'undefined'；寻找全局函数声明，把它作为window的方法加入到window对象中，并将函数体赋值给他（匿名函数是不参与预编译的，因为它是变量）。而变量提升作为不合理的地方在ES6中已经解决了，函数提升还存在。
4. 解释执行：执行到变量就赋值，如果变量没有被定义，也就没有被预编译直接赋值，在ES5非严格模式下这个变量会成为window的一个属性，也就是成为全局变量。string、int这样的值就是直接把值放在变量的存储空间里，object对象就是把指针指向变量的存储空间。函数执行，就将函数的环境推入一个环境的栈中，执行完成后再弹出，控制权交还给之前的环境。JS作用域其实就是这样的执行流机制实现的。

+++

+++info 前端如何上传大文件
`前端`
断点续传，利用Blob.prototype.slice方法返回原文件的某个切片，并将切片通过http并发上传，同时要注意记录切片顺序和最大数量信息
`后端`
在切片接收达到最大数量时即开始合并切片，可以使用nodejs 的api fs.appendFileSync,先创建一个最终文件再逐步合并到此文件中
+++

+++info 同源策略以及如何跨域
同源策略：协议域名端口相同才可以发送请求
跨域：

1. CORS：服务端设置Access-Control-Allow-Origin
2. 代理：设置代理服务器
3. JSONP：通过script标签get请求某个api
+++

+++info 如何实现浏览器标签页之间的通信
`中介者模式`

1. 使用WebSocket将消息发送给服务器再在推给另一个客户端
2. 调用本地存储如localStorage传递数据

`发布订阅者`

1. 调用webWorker的postMessage
+++

+++info 讲讲CDN负载均衡
CDN 是一个内容分发网络，通过对源网站资源的缓存，利用本身多台位于不同地域、不同运营商的服务器，向用户提供资源就近访问的功能。用户的请求并不是直接发送给源网站，而是发送给 CDN 服务器，由 CDN 服务器将请求定位到最近的含有该资源的服务器上去请求。这样有利于提高网站的访问速度，同时通过这种方式也减轻了源服务器的访问压力。
CDN访问过程：

1. 用户输入访问的域名,操作系统向 LocalDns 查询域名的 ip 地址
2. LocalDns 向 ROOT DNS 查询域名的授权服务器(这里假设 LocalDns 缓存过期)，ROOT DNS 将域名授权 dns 记录回应给 LocalDns
3. LocalDns 得到域名的授权 dns 记录后,继续向域名授权 dns 查询域名的 ip 地址域名授权 dns 查询域名记录后(一般是 CNAME )，回应给 LocalDns
4. LocalDns 得到域名记录后,向智能调度 DNS 查询域名的 ip 地址，智能调度 DNS 根据一定的算法和策略(比如静态拓扑，容量等),将最适合的 CDN 节点 ip 地址回应给 LocalDns
5. LocalDns 将得到的域名 ip 地址，回应给 用户端，用户得到域名 ip 地址后，访问站点服务器
6. CDN 节点服务器应答请求，将内容返回给客户端.(缓存服务器一方面在本地进行保存，以备以后使用，二方面把获取的数据返回给客户端，完成数据服务过程)
+++

### 安全

### 存储

+++success web存储方式与特性
| 存储          | 大小 | 特性          |
|--------------|------|--------------|
|cookie        | 4KB  |请求携带       |
|localStorage  | 5MB  |持久存储       |
|sessionStorage| 5MB  |关闭页面自动删除|
|indexDB       | 无限  |数据库        |
+++

+++success 谈谈cookie的缺点
缺点：

1. 大小不能超过4KB
2. cookie被人拦截后可以直接使用
+++

+++success 强缓存和协商缓存
浏览器请求时会执行强缓存，若本地没有缓存则会发送请求进行协商缓存
`强缓存：`
通过expire记录过期日期，http1.1中新增cache-control克服请求头限制，且优先级高于expire
cache-control:no-cache/private/max-age=3600...（具体可到MDN查看）
(https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control)

`协商缓存`
ETag+if-none-match和last-modified+if-modified-since,前者优先级大于后者
服务器返回页面A，并在给A加上一个ETag。 客户端展现该页面，并将页面连同ETag一起缓存。 客户再次请求页面A，并将上次请求时服务器返回的ETag一起传递给服务器。 服务器检查该ETag，并判断出该页面自上次客户端请求之后还未被修改，直接返回响应304（未修改——Not Modified）和一个空的响应体。
+++

+++success 浏览器缓存位置
Service Worker
Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 Service Worker 的话，传输协议必须为 HTTPS。Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由缓存哪些文件、如何匹配缓存、如何读取缓存，而缓存是可持续性的。Service Worker 也是 PWA 的核心技术。
Memory Cache
Memory Cache 也就是内存中的缓存，主要包含的是当前页面中已经抓取到的资源，例如页面上已经下载的样式、脚本、图片等。读取内存中的数据很高效，但是缓存持续性很短，会随着进程的释放而释放。一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。
Disk Cache
Disk Cache 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache 胜在容量和存储时效性上。在所有浏览器缓存中，Disk Cache 覆盖面基本上是最大的。它会根据 HTTPHeader 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。绝大部分的缓存都来自 Disk Cache。
Push Cache
Push Cache（推送缓存）是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被时候用。它只在会话（Session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂（大约 5 分钟）。
+++
