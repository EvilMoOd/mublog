---
title: HTML
description: "本模块主要包含HTML、网络和浏览器三大块知识，因为习惯三件套的说法，所以把后两者都归类到HTML中，实际上按内容来划分的话，网络>浏览器>HTML。"
---

## HTML

+++danger Doctype作用? 标准模式与兼容模式如何区分？
<!DOCTYPE> 声明位于文档中的最前面，处于html标签之前。告知浏览器以何种模式来渲染文档。
标准模式的排版和 JS 运作模式是 以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现。
+++

+++danger 语义化标签

1. 利于SEO
2. 提高代码可读性
+++

+++danger  说一下 HTML5 drag api
darg：事件主体是被拖放元素，在正在拖放被拖放元素时触发。
dragstart：事件主体是被拖放元素，在开始拖放被拖放元素时触发，。
dragend：事件主体是被拖放元素，在整个拖放操作结束时触发
dragenter：事件主体是目标元素，在被拖放元素进入某元素时触发。
dragover：事件主体是目标元素，在被拖放在某元素内移动时触发。
dragleave：事件主体是目标元素，在被拖放元素移出目标元素是触发。
drop：事件主体是目标元素，在目标元素完全接受被拖放元素时触发。
+++

## 网络

+++warning 七层模型和相关协议
应用层：允许访问OSI环境的手段（应用协议数据单元APDU）
表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）
会话层：建立、管理和终止会话（会话协议数据单元SPDU）
传输层：提供端到端的可靠报文传递和错误恢复（段Segment）
网络层：负责数据包从源到宿的传递和网际互连（包PackeT）
数据链路层：将比特组装成帧和点到点的传递（帧Frame）
物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）

ICMP协议： 因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。
TFTP协议： 是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。
HTTP协议： 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。
DHCP协议： 动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置参数手段。
+++

### HTTP

+++warning 谈谈网络性能优化

1. 避免请求：采用强缓存和协商缓存，DNS缓存，CDN负载均衡
2. 减少请求：1.资源的懒加载 2.合并请求，如将静态资源合并成一个大文件 3.代理重定向
3. 压缩：1.图片视频等资源进行有损压缩 2.代码文本类进行无损压缩（Gzip）
+++

#### HTTP各个版本

+++warning 简述HTTP各个版本改进
`HTTP2.0`

1. 二进制格式：HTTP2.0 基本单位为二进制，以往是采用文本形式，健壮性不是很好，现在采用二进制格式，更方便更健壮
2. 多路复用：把多个请求当做多个流，请求响应数据分成多个帧，不同流中的帧交错发送，解决了 TCP 连接数量多、慢和队头阻塞的问题，所以对于同一个域名只用创建一个连接就可以了
3. 压缩消息头：客户端和服务端共同维护一个字典，重复发送同样请求头时只需要发送索引即可
4. HTTP2.0 服务端推送，浏览器发送请求后，服务端会主动发送与这个请求相关的资源，之后浏览器就不用再次发送后续的请求了

`HTTP1.1`

1. 缓存处理新增 E-Tag、If-None-Match 之类的缓存来来控制缓存
2. 长连接，可以在一个 TCP 连接上发送多个请求和响应，但存在队头阻塞问题
+++

+++warning 谈谈HTTP2中的多路复用
在 HTTP1.1中即使开启了 Keep-Alive，解决了多次连接的问题，但是依然有两个效率上的问题：
一是服务端必须顺序响应文件，容易造成队头阻塞，二是连接数过多导致的性能问题。
HTTP2 的多路复用就是为了解决上述的两个性能问题。
在 HTTP/2 中，有两个非常重要的概念，分别是帧（frame）和流（stream）。帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流。
多路复用，就是在一个 TCP 连接中可以存在多条流。换句话说，也就是可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。通过这个技术，可以避免 HTTP 旧版本中的队头阻塞问题，极大的提高传输性能。
+++

#### HTTPS

+++warning SSL连接断开后如何恢复
Session id：通过将会话时产生的编号再一次传给服务器，若服务器有该记录则可以继续使用
Session Ticket：session ticket 是服务器在上一次对话中发送给客户的，这个 ticket 是加密的，只有服务器可能够解密，里面包含了本次会话的信息，比如对话密钥和加密方法等。这样不管我们的请求是否转移到其他的服务器上，当服务器将 ticket 解密以后，就能够获取上次对话的信息，就不用重新生成对话秘钥了。
+++

### TCP/UDP/WebSocket

+++warning TCP三次握手四次挥手
`握手：`

1. 发送端发送SYN标志（我要发送请求）
2. 接收端回复一个SYN/ACK（ok收到，你发吧）
3. 发送端再回复ACK握手结束（ok）
`挥手`
1. 主动关闭方发送FIN（我要关闭请求了）【注意这里如果还有未完毕的请求（未收到对方ACK）会继续发送或接收】
2. 被关闭方回复ACK（知道了，等我这边处理请求完先）
3. 被关闭方发送FIN（处理完了，我也要关闭请求了）
4. 主动关闭方回复ACK（知道了）
:::warning no-icon
如果省略第三次握手，则遇到网络差的情况会阻塞导致再建立一条新的TCP握手请求，等到网络畅通时旧的网络请求会再工作导致bug
:::
+++

+++warning TCP和UDP的区别
TCP是面向有连接的协议，一对一、可靠、面向字节流
UDP是面向无连接的协议，一对多、不可靠、面向报文
+++

+++warning 什么是粘包问题，如何解决？
默认情况下，TCP 连接会采用延迟传送算法（Nagle 算法），在数据发送之前缓存他们。如果短时间有多个数据发送，会缓冲到一起作一次发送（缓冲大小是 socket.bufferSize），这样可以减少 IO 消耗提高性能。（TCP 会出现这个问题，HTTP 协议解决了这个问题）

`解决方法`

1. 多次发送之前间隔一个等待时间：处理简单，但是影响传输效率
2. 关闭 Nagle 算法：消耗资源高，整体性能下降
3. 封包/拆包：使用一些有标识来进行封包拆包（类似 HTTP 协议头尾）

+++

+++warning A、B 机器正常连接后，B 机器突然重启，问 A 此时处于 TCP 什么状态?
因为 B 会在重启之后进入 tcp 状态机的 listen 状态，只要当 a 重新发送一个数据包（无论是 syn 包或者是应用数据），b 端应该会主动发送一个带 rst 位的重置包来进行连接重置，所以 a 应该在 syn_sent 状态
+++

## 浏览器

### 机制

+++info 渲染机制、回流与重绘、如何避免

1. 浏览器采用流式布局模型（Flow Based Layout）；
2. 浏览器会把 HTML 解析成 DOM，把 CSS 解析成 CSSOM,DOM 和 CSSOM 合并就产生了渲染树（Render Tree）；
3. 有了 RenderTree，我们就知道了所有节点的样式，然后计算他们在页面上的大小和位置，最后把节点绘制到页面上；
4. 由于浏览器使用流式布局，对 Render Tree 的计算通常只需要遍历一次就可以完成，但 table 及其内部元素除外，他们可能需要多次计算，通常要花 3 倍于同等元素的时间，这也是为什么要避免使用 table 布局的原因之一；

`回流`
布局或者几何属性改变时触发回流。回流是影响浏览器性能的关键因素，因为其变化涉及到部分页面（或是整个页面）的布局更新。一个元素的回流可能会导致其素有子元素以及 DOM 中紧随其后的节点、祖先节点元素的随后的回流。大部分的回流将导致页面的重新渲染。回流必定会发生重绘，重绘不一定会引发回流。
`重绘`
由于节点的集合属性发生改变或者由于样式改变而不会影响布局的，成为重绘，例如 outline、visibility、color、background-color 等

减少回流和重绘

`CSS`

- 使用 transform 代替 top
- 使用 visibility 替换 display: none，前者引起重绘，后者引发回流
- 避免使用 table 布局
- 尽可能在 DOM 树的最末端改变 class
- 避免设置多层内联样式，CSS 选择符从右往左匹配查找，避免节点层级过多
- 将动画效果应用到 position 属性为 absolute 或 fixed 的元素上，避免影响其他元素的布局
- 避免使用 CSS 表达式，可能会引发回流
- CSS 硬件加速

`Javascript`

- 避免频繁操作样式，修改 class 最好
- 避免频繁操作 DOM，合并多次修改为一次
- 避免频繁读取会引发回流/重绘的属性，将结果缓存
- 对用户改变窗口的操作进行防抖处理
+++

+++info 父进程或子进程的死亡是否会影响对方? 什么是孤儿进程?僵尸进程?
子进程死亡不会影响父进程，不过子进程死亡时，会向它的父进程发送死亡信号。反之父进程死亡，一般情况下子进程也会随之死亡，但如果此时子进程处于可运行状态、僵死状态等等的话，子进程将被 init 进程收养，从而成为孤儿进程。
子进程死亡的时候（处于“终止状态”），父进程没有及时调用 wait() 或 waitpid() 来返回死亡进程的相关信息，此时子进程还有一个 PCB 残留在进程表中，被称为僵尸进程。
+++

### 网络相关

+++info 一个页面从输入URL到页面加载显示完成，这个过程中都发生了什么？
请求：

1. 浏览器会开启一个线程来处理这个请求，如果是关键字则启动对应搜索引擎，如果输入是url则同时在远程DNS服务器上启动一个DNS查询。这能使浏览器获得请求对应的IP地址（如果是IP地址则跳过DNS）。
2. 浏览器与远程 Web 服务器通过 TCP 三次握手协商来建立一个 TCP/IP 连接。该握手包括一个同步报文，一个同步-应答报文和一个应答报文，这三个报文在浏览器和服务器之间传递。该握手首先由客户端尝试建立起通信，而后服务器应答并接受客户端的请求，最后由客户端发出该请求已经被接受的报文。
3. 一旦 TCP/IP 连接建立，浏览器会通过该连接向远程服务器发送 HTTP 请求。远程服务器找到资源并使用HTTP响应返回该资源，值为200的HTTP响应状态表示一个正确的响应。
4. 此时， Web 服务器提供资源服务，客户端开始下载资源。

渲染：
`1、解析`
解析收到的文档，根据文档构建一颗DOM树，DOM 树是由 DOM元素及属性节点组成的。
然后对 CSS 进行解析，生成CSSOM规则树
根据 DOM 树和 CSSOM 规则树构建 Render Tree。渲染树的节点被称为渲染对象，渲染对象是一个包含有颜色和大小等属性的矩形，渲染对象和DOM 对象相对应，但这种对应关系不是一对一的，不可见的 DOM 元素不会被插入渲染树。
下载JS脚本、图片等资源
`2、布局`
接着就会根据渲染树来进行布局（也可以叫做回流）。这一阶段浏览器要做的事情就是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动重排”。
`3、绘制`
布局阶段结束后是绘制阶段，比那里渲染树并调用对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组件。为了更好的用户体验，渲染引擎会尽可能早的将内容呈现到屏幕上，并不会等到所有的 html 解析完成之后再去构建和布局 render tree。它是解析完一部分内容就显示一部分内容，同时可能还在网络下载其余内容。

+++

+++info 前端如何上传大文件
`前端`
断点续传，利用Blob.prototype.slice方法返回原文件的某个切片，并将切片通过http并发上传，同时要注意记录切片顺序和最大数量信息
`后端`
在切片接收达到最大数量时即开始合并切片，可以使用nodejs 的api fs.appendFileSync,先创建一个最终文件再逐步合并到此文件中
+++

+++info 同源策略以及如何跨域
同源策略：协议域名端口相同才可以发送请求
跨域：

1. CORS：服务端设置Access-Control-Allow-Origin
2. 代理：设置代理服务器
3. JSONP：通过script标签get请求某个api
+++

+++info 如何实现浏览器标签页之间的通信
`中介者模式`

1. 使用WebSocket将消息发送给服务器再在推给另一个客户端
2. 调用本地存储如localStorage传递数据
`发布订阅者`
1. 调用webWorker的postMessage
+++

+++info 讲讲CDN负载均衡
CDN 是一个内容分发网络，通过对源网站资源的缓存，利用本身多台位于不同地域、不同运营商的服务器，向用户提供资源就近访问的功能。用户的请求并不是直接发送给源网站，而是发送给 CDN 服务器，由 CDN 服务器将请求定位到最近的含有该资源的服务器上去请求。这样有利于提高网站的访问速度，同时通过这种方式也减轻了源服务器的访问压力。
CDN访问过程：

1. 用户输入访问的域名,操作系统向 LocalDns 查询域名的 ip 地址
2. LocalDns 向 ROOT DNS 查询域名的授权服务器(这里假设 LocalDns 缓存过期)，ROOT DNS 将域名授权 dns 记录回应给 LocalDns
3. LocalDns 得到域名的授权 dns 记录后,继续向域名授权 dns 查询域名的 ip 地址域名授权 dns 查询域名记录后(一般是 CNAME )，回应给 LocalDns
4. LocalDns 得到域名记录后,向智能调度 DNS 查询域名的 ip 地址，智能调度 DNS 根据一定的算法和策略(比如静态拓扑，容量等),将最适合的 CDN 节点 ip 地址回应给 LocalDns
5. LocalDns 将得到的域名 ip 地址，回应给 用户端，用户得到域名 ip 地址后，访问站点服务器
6. CDN 节点服务器应答请求，将内容返回给客户端.(缓存服务器一方面在本地进行保存，以备以后使用，二方面把获取的数据返回给客户端，完成数据服务过程)
+++

### 安全

### 存储

+++success web存储方式与特性
| 存储          | 大小 | 特性          |
|--------------|------|--------------|
|cookie        | 4KB  |请求携带       |
|localStorage  | 5MB  |持久存储       |
|sessionStorage| 5MB  |关闭页面自动删除|
|indexDB       | 无限  |数据库        |
+++

+++success 谈谈cookie的缺点
缺点：

1. 大小不能超过4KB
2. cookie被人拦截后可以直接使用
+++

+++success 强缓存和协商缓存
浏览器请求时会执行强缓存，若本地没有缓存则会发送请求进行协商缓存
`强缓存：`
通过`expire`记录过期日期，http1.1中新增`cache-control`克服请求头限制，且优先级高于expire
cache-control:no-cache/private/max-age=3600
`协商缓存`
ETag+if-none-match和last-modified+if-modified-since,前者优先级大于后者
服务器返回页面A，并在给A加上一个ETag。 客户端展现该页面，并将页面连同ETag一起缓存。 客户再次请求页面A，并将上次请求时服务器返回的ETag一起传递给服务器。 服务器检查该ETag，并判断出该页面自上次客户端请求之后还未被修改，直接返回响应304（未修改——Not Modified）和一个空的响应体。
+++

+++success 浏览器缓存位置
Service Worker
Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 Service Worker 的话，传输协议必须为 HTTPS。Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由缓存哪些文件、如何匹配缓存、如何读取缓存，而缓存是可持续性的。Service Worker 也是 PWA 的核心技术。
Memory Cache
Memory Cache 也就是内存中的缓存，主要包含的是当前页面中已经抓取到的资源，例如页面上已经下载的样式、脚本、图片等。读取内存中的数据很高效，但是缓存持续性很短，会随着进程的释放而释放。一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。
Disk Cache
Disk Cache 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache 胜在容量和存储时效性上。在所有浏览器缓存中，Disk Cache 覆盖面基本上是最大的。它会根据 HTTPHeader 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。绝大部分的缓存都来自 Disk Cache。
Push Cache
Push Cache（推送缓存）是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被时候用。它只在会话（Session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂（大约 5 分钟）。
+++
